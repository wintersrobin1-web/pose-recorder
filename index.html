<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pose Recorder (MP4 auf iPhone)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    video, canvas { max-width: 100%; width: 480px; height: auto; border: 1px solid #ddd; border-radius: 10px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button.primary { border-color: #111; }
    button:disabled { opacity: 0.5; }
    label { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; }
    .hint { color: #555; font-size: 14px; line-height: 1.4; max-width: 980px; }
    .small { font-size: 13px; color: #666; }
    .warn { color: #7a4; }
    .err { color: #a33; }
  </style>

  <!-- MediaPipe (klassisch, ohne ES-Module) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
</head>

<body>
  <h1>Pose Recorder (Skelett-Video, iPhone: MP4 bevorzugt)</h1>
  <p class="hint">
    Links: Live-Kamera (nur zur Erkennung). Rechts: Canvas (wird gespeichert) mit Skelett und optional anonymer Silhouette.
    Gespeichert wird nur das Canvas-Video, nicht das Kamerabild.
  </p>

  <div class="row">
    <button id="btnInit" class="primary">Kamera aktivieren (Rückkamera)</button>
    <button id="btnRec" disabled>Aufnahme starten</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnShare" disabled>Teilen/Speichern</button>
  </div>

  <div class="row">
    <label>
      <input type="checkbox" id="toggleSilhouette" checked />
      Silhouette (anonym) einblenden
    </label>
    <label>
      <input type="checkbox" id="toggleSpine" checked />
      Mittelachse („Wirbelsäule“) einblenden
    </label>
    <span class="small">Tipp: Wenn Silhouette im Schwimmbad flackert, deaktivieren.</span>
  </div>

  <div class="row">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <h3>Vorschau (das ist die gespeicherte Datei)</h3>
  <video id="preview" controls playsinline style="display:none;"></video>

  <p class="hint" id="status">Status: bereit</p>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const preview = document.getElementById("preview");

    const btnInit = document.getElementById("btnInit");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const statusEl = document.getElementById("status");

    const toggleSilhouette = document.getElementById("toggleSilhouette");
    const toggleSpine = document.getElementById("toggleSpine");

    function setStatus(s, cls) {
      statusEl.className = "hint" + (cls ? (" " + cls) : "");
      statusEl.textContent = "Status: " + s;
    }

    // -----------------------------
    // Recording (Canvas -> Video)
    // -----------------------------
    let recorder = null;
    let recordedChunks = [];
    let lastBlob = null;
    let lastMime = "";
    let lastObjectUrl = "";

    function pickBestMimeType() {
      if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";

      // iPhone/Safari: MP4/H.264 ist am kompatibelsten, wenn unterstützt.
      // Wir probieren mehrere mp4 codec-Strings, dann WebM als Fallback.
      const candidates = [
        'video/mp4;codecs="avc1.42E01E"',     // H.264 baseline
        'video/mp4;codecs="avc1.4D401E"',     // H.264 main
        "video/mp4",
        'video/webm;codecs="vp8"',
        "video/webm"
      ];

      for (const t of candidates) {
        try {
          if (MediaRecorder.isTypeSupported(t)) return t;
        } catch (_) {}
      }
      return "";
    }

    function resetPreview() {
      if (lastObjectUrl) URL.revokeObjectURL(lastObjectUrl);
      lastObjectUrl = "";
      preview.style.display = "none";
      preview.removeAttribute("src");
      preview.load();
    }

    function showPreview(blob) {
      resetPreview();
      lastObjectUrl = URL.createObjectURL(blob);
      preview.src = lastObjectUrl;
      preview.style.display = "block";
    }

    function startRecording() {
      resetPreview();
      recordedChunks = [];
      lastBlob = null;
      lastMime = "";
      btnShare.disabled = true;

      const fps = 15;
      const stream = canvas.captureStream(fps);

      const mimeType = pickBestMimeType();
      const options = mimeType ? { mimeType } : undefined;

      try {
        recorder = new MediaRecorder(stream, options);
      } catch (e) {
        // Wenn die Erstellung scheitert, nochmal ohne Optionen probieren
        recorder = new MediaRecorder(stream);
      }

      lastMime = recorder.mimeType || mimeType || "";
      recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };

      recorder.onstop = () => {
        const type = recorder.mimeType || lastMime || "video/mp4";
        lastBlob = new Blob(recordedChunks, { type });

        // Vorschau direkt anzeigen (entscheidend auf iOS)
        showPreview(lastBlob);

        btnShare.disabled = !lastBlob;

        const ext = type.includes("mp4") ? "mp4" : (type.includes("webm") ? "webm" : "bin");
        if (ext === "webm") {
          setStatus("Aufnahme fertig (WebM). Hinweis: WebM kann auf iPhone unzuverlässig abspielbar sein – MP4 wäre ideal.", "warn");
        } else {
          setStatus("Aufnahme fertig (MP4).", "");
        }
      };

      recorder.start(200);
      setStatus("Aufnahme läuft…");
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") recorder.stop();
    }

    async function shareOrDownload() {
      if (!lastBlob) return;

      const type = lastBlob.type || lastMime || "";
      const ext = type.includes("mp4") ? "mp4" : (type.includes("webm") ? "webm" : "bin");
      const fileName = `pose_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
      const file = new File([lastBlob], fileName, { type: lastBlob.type });

      // iOS Share Sheet
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: "Pose-Aufnahme" });
        setStatus("Geteilt/gespeichert.");
        return;
      }

      // Fallback: Download-Link
      const url = URL.createObjectURL(lastBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Download gestartet.");
    }

    // -----------------------------
    // MediaPipe Pose
    // -----------------------------
    let pose = null;
    let cam = null;

    function resizeCanvasToVideo() {
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      canvas.width = w;
      canvas.height = h;
    }

    function midPoint(a, b) {
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    }

    function drawSpineIfWanted(landmarks) {
      if (!toggleSpine.checked) return;
      const ls = landmarks[11], rs = landmarks[12], lh = landmarks[23], rh = landmarks[24];
      if (!ls || !rs || !lh || !rh) return;

      const ms = midPoint(ls, rs);
      const mh = midPoint(lh, rh);

      const x1 = ms.x * canvas.width, y1 = ms.y * canvas.height;
      const x2 = mh.x * canvas.width, y2 = mh.y * canvas.height;

      ctx.save();
      ctx.lineWidth = 12;
      ctx.lineCap = "round";
      ctx.shadowBlur = 8;
      ctx.shadowColor = "black";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }

    function drawOutput(results) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!results) return;

      // Silhouette (anonym)
      if (toggleSilhouette.checked && results.segmentationMask && window.drawMask) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        window.drawMask(
          ctx,
          results.segmentationMask,
          results.segmentationMask,
          { fillColor: "white" },
          { fillColor: "transparent" }
        );
        ctx.restore();
      }

      if (!results.poseLandmarks) return;

      const drawConnectorsFn = window.drawConnectors;
      const drawLandmarksFn = window.drawLandmarks;
      const connections = window.POSE_CONNECTIONS;
      if (!drawConnectorsFn || !drawLandmarksFn || !connections) return;

      ctx.save();
      ctx.shadowBlur = 8;
      ctx.shadowColor = "black";
      drawConnectorsFn(ctx, results.poseLandmarks, connections, { lineWidth: 12 });
      drawLandmarksFn(ctx, results.poseLandmarks, { radius: 7 });
      ctx.restore();

      drawSpineIfWanted(results.poseLandmarks);
    }

    async function initAll() {
      btnInit.disabled = true;
      setStatus("initialisiere…");

      pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: true,
        smoothSegmentation: true,
        selfieMode: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults(drawOutput);

      // Wichtig: nur Camera(...) nutzen, sonst Kamera-Switch
      cam = new Camera(video, {
        onFrame: async () => { await pose.send({ image: video }); },
        width: 1280,
        height: 720,
        facingMode: "environment"
      });

      await cam.start();
      resizeCanvasToVideo();

      btnRec.disabled = false;
      setStatus("bereit (Rückkamera + Skelett läuft).");
    }

    // -----------------------------
    // UI wiring
    // -----------------------------
    btnInit.addEventListener("click", async () => {
      try {
        await initAll();

        // Kurzer Info-Hinweis zum Recording-Format
        const mt = pickBestMimeType();
        if (mt.includes("webm")) {
          setStatus("bereit. Hinweis: Dein iPhone unterstützt scheinbar kein MP4-Recording; WebM kann unzuverlässig sein.", "warn");
        }
      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + (err && err.message ? err.message : String(err)), "err");
        btnInit.disabled = false;
      }
    });

    btnRec.addEventListener("click", () => {
      btnRec.disabled = true;
      btnStop.disabled = false;
      startRecording();
    });

    btnStop.addEventListener("click", () => {
      btnStop.disabled = true;
      stopRecording();
      btnRec.disabled = false;
    });

    btnShare.addEventListener("click", () => shareOrDownload());
  </script>
</body>
</html>
