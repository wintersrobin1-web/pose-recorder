<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MOTAXIS - Anonyme Bewegungsanalyse</title>

<style>
:root{
  --bg: #bfe7ff;
  --ink: #0f172a;
  --muted: #475569;
  --card: #ffffff;
  --border: #e5e7eb;
  --introBg: #f8fafc;
  --introBorder: #e2e8f0;
  --accent: #111827;
}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:16px;color:var(--ink);background:#fff}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
.hint{color:var(--muted);font-size:14px;line-height:1.45;max-width:1100px}
.header{border:1px solid var(--border);border-radius:16px;padding:14px 14px 12px;margin-bottom:12px;background:var(--card);max-width:1100px}
.brand{display:flex;flex-direction:column;gap:2px;margin-bottom:10px}
.brand .logo{font-weight:900;letter-spacing:1.6px;font-size:26px;line-height:1.05;text-transform:uppercase;color:var(--accent)}
.brand .sub{font-weight:700;letter-spacing:.6px;font-size:13px;color:#334155;text-transform:uppercase}
.introBox{border:1px solid var(--introBorder);border-radius:14px;padding:12px 14px;background:var(--introBg)}
.introBox p{margin:0;color:#1f2a33;font-size:13.75px;line-height:1.45;text-align:left}
.stack{display:grid;grid-template-columns:1fr;gap:12px;max-width:1100px}
.block{border:1px solid var(--border);border-radius:12px;padding:10px 12px;background:var(--card)}
.blockTitle{font-weight:800;margin:0 0 10px 0;font-size:13px;color:#0b1220;letter-spacing:.2px}
details{border:1px solid var(--border);border-radius:12px;padding:10px 12px;background:var(--card)}
summary{cursor:pointer;font-weight:800;color:#0b1220}
label{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid var(--border);border-radius:10px;background:var(--card);font-size:14px}
select{padding:9px 12px;border-radius:10px;border:1px solid #cbd5e1;background:var(--card);font:inherit;color:#0b1220}
button{padding:10px 14px;border-radius:10px;border:1px solid #cbd5e1;background:var(--card);font:inherit;color:#0b1220}
button.primary{border-color:#0b1220;font-weight:700}
button:disabled{opacity:.5}
.btnRow{display:flex;gap:10px;flex-wrap:wrap}
.btnRow button{flex:1 1 auto}
.btnRow .wide{flex:1 1 100%}
video,canvas{max-width:100%;border:1px solid var(--border);border-radius:10px}
video{width:360px;height:auto;background:#000}
canvas{width:360px;height:auto;background:var(--bg)}
.videoHidden{width:1px!important;height:1px!important;opacity:0!important;position:absolute!important;left:-9999px!important;top:-9999px!important;pointer-events:none!important}
.rangeWrap{display:flex;align-items:center;gap:10px;padding:8px 10px;border:1px solid var(--border);border-radius:10px;margin-top:10px;flex-wrap:wrap;background:var(--card)}
.rangeWrap span{min-width:170px;font-size:13px;color:#475569}
.small{font-size:13px;color:#475569;min-width:64px;text-align:right}
.tipsBox{margin-top:10px;border:2px solid #16a34a;border-radius:12px;padding:10px 12px;background:#f0fdf4;display:none;max-width:1100px}
.tipsBox h3{margin:0 0 6px 0;font-size:14px}
.tipsBox ul{margin:6px 0 0 18px;padding:0}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #bbf7d0;font-size:12px;color:#14532d;background:#ecfdf5;margin-left:6px}
#status{margin-top:12px;max-width:1100px}
</style>
</head>

<body>
<div class="header">
  <div class="brand">
    <div class="logo">MOTAXIS</div>
    <div class="sub">Anonyme Bewegungsanalyse</div>
  </div>
  <div class="introBox">
    <p>Beta-Version zur anonymen Aufnahme und Analyse von Skelettachsen und Bewegungen. Bislang optimiert für Brustschwimmen.</p>
  </div>
</div>

<video id="video" class="videoHidden" playsinline autoplay muted></video>

<div class="stack">
  <div class="block">
    <div class="blockTitle">Kamera</div>
    <div class="btnRow">
      <button id="btnInit" class="primary wide">Kamera aktivieren</button>
      <button id="btnSwitch" disabled class="wide">Kamera wechseln (Rück)</button>
    </div>
  </div>

  <details open>
    <summary>Anzeige (allgemein)</summary>
    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
      <label><input type="checkbox" id="toggleSkeleton" checked /> Skelett</label>
      <label><input type="checkbox" id="toggleSilhouette" checked /> Segmentierung</label>

      <label style="border:none; padding:0; background:transparent;">
        <span style="font-weight:800; color:#0b1220;">Kameraperspektive</span>
      </label>

      <select id="filmingPreset">
        <option value="side45" selected>Schräg seitlich (leicht von oben)</option>
        <option value="back45">Schräg von hinten (leicht von oben)</option>
        <option value="stand">Frontal (Stand)</option>
      </select>
    </div>

    <details style="margin-top:10px;">
      <summary>Erweiterte Einstellungen</summary>

      <div class="rangeWrap">
        <span>Input-Video anzeigen</span>
        <label style="border:none; padding:0; border-radius:0;">
          <input type="checkbox" id="showInputVideo" />
          <span class="small">anzeigen</span>
        </label>
        <span class="hint" style="max-width:none;">(Optional – Output bleibt anonym.)</span>
      </div>

      <div class="rangeWrap">
        <span>Segmentierung – Deckkraft</span>
        <input id="silOpacity" type="range" min="0" max="1" step="0.05" value="0.40">
        <span id="silOpacityVal" class="small">0.40</span>
      </div>

      <div class="rangeWrap">
        <span>Segmentierung – Schwelle</span>
        <input id="silThresh" type="range" min="0" max="100" step="1" value="70">
        <span id="silThreshVal" class="small">70</span>
      </div>

      <div class="rangeWrap">
        <span>Skelett – Linienstärke</span>
        <input id="skelLine" type="range" min="1" max="10" step="1" value="3">
        <span id="skelLineVal" class="small">3</span>
      </div>

      <div class="rangeWrap">
        <span>Skelett – Punkt-Radius</span>
        <input id="skelDot" type="range" min="1" max="10" step="1" value="4">
        <span id="skelDotVal" class="small">4</span>
      </div>
    </details>
  </details>

  <div class="block">
    <div class="blockTitle">Aufnahme</div>
    <div class="btnRow">
      <button id="btnRec" disabled class="wide">Aufnahme starten</button>
      <button id="btnStop" disabled>Stop</button>
      <button id="btnShare" disabled>Teilen/Speichern</button>
      <button id="btnReset" disabled class="wide">Slots zurücksetzen</button>
    </div>
  </div>

  <div>
    <canvas id="canvas"></canvas>
  </div>

  <div id="tipsBox" class="tipsBox">
    <h3>Techniktipps Brustschwimmen <span id="hintMeta" class="pill"></span></h3>
    <div class="hint" id="hintText"></div>
    <ul id="hintList"></ul>
  </div>
</div>

<p class="hint mono" id="status">Status: bereit</p>

<script type="module">
import { FilesetResolver, PoseLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

// =========================
// PERF KNOBS (wichtig)
// =========================
const MASK_FPS = 10; // Maske neu berechnen (Pixel-Loop) nur 10 fps
const TIPS_FPS = 12; // Heuristiken/Statistik nur 12 fps

// =========================
// DOM + UI
// =========================
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const btnInit = document.getElementById("btnInit");
const btnSwitch = document.getElementById("btnSwitch");
const btnRec = document.getElementById("btnRec");
const btnStop = document.getElementById("btnStop");
const btnShare = document.getElementById("btnShare");
const btnReset = document.getElementById("btnReset");

const toggleSkeleton = document.getElementById("toggleSkeleton");
const toggleSilhouette = document.getElementById("toggleSilhouette");
const filmingPreset = document.getElementById("filmingPreset");

const showInputVideo = document.getElementById("showInputVideo");
const silOpacity = document.getElementById("silOpacity");
const silThresh = document.getElementById("silThresh");
const skelLine  = document.getElementById("skelLine");
const skelDot   = document.getElementById("skelDot");

const silOpacityVal = document.getElementById("silOpacityVal");
const silThreshVal  = document.getElementById("silThreshVal");
const skelLineVal   = document.getElementById("skelLineVal");
const skelDotVal    = document.getElementById("skelDotVal");

const tipsBox = document.getElementById("tipsBox");
const hintList = document.getElementById("hintList");
const hintText = document.getElementById("hintText");
const hintMeta = document.getElementById("hintMeta");

const statusEl = document.getElementById("status");
const setStatus = (s) => statusEl.textContent = "Status: " + s;

function bindSlider(el, out, fmt=(v)=>Number(v).toFixed(2)) {
  const update = () => out.textContent = fmt(el.value);
  el.addEventListener("input", update);
  update();
}
bindSlider(silOpacity, silOpacityVal, v => Number(v).toFixed(2));
bindSlider(silThresh,  silThreshVal,  v => String(Math.round(Number(v))));
bindSlider(skelLine,   skelLineVal,   v => String(Math.round(Number(v))));
bindSlider(skelDot,    skelDotVal,    v => String(Math.round(Number(v))));

function setInputVideoVisible(visible) {
  if (visible) video.classList.remove("videoHidden");
  else video.classList.add("videoHidden");
}
setInputVideoVisible(false);
showInputVideo?.addEventListener("change", () => setInputVideoVisible(showInputVideo.checked));

// =========================
// HiDPI Canvas
// =========================
function isPortraitUI() {
  const so = screen.orientation && screen.orientation.type;
  if (typeof so === "string") return so.includes("portrait");
  if (window.matchMedia) return window.matchMedia("(orientation: portrait)").matches;
  return window.innerHeight >= window.innerWidth;
}
let CSS_W = 360, CSS_H = 640;
function setupHiDPICanvas(cssW, cssH) {
  CSS_W = cssW; CSS_H = cssH;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.imageSmoothingEnabled = false;
}
function applyLayoutFromOrientation() {
  if (isPortraitUI()) setupHiDPICanvas(360, 640);
  else setupHiDPICanvas(720, 405);
}
window.addEventListener("resize", applyLayoutFromOrientation);
window.addEventListener("orientationchange", applyLayoutFromOrientation);
applyLayoutFromOrientation();

const BG = "#bfe7ff";

// =========================
// Pose connections
// =========================
const POSE_CONNECTIONS = [
  [0,1],[1,2],[2,3],[3,7],
  [0,4],[4,5],[5,6],[6,8],
  [9,10],
  [11,12],
  [11,13],[13,15],[15,17],[15,19],[15,21],
  [12,14],[14,16],[16,18],[16,20],[16,22],
  [11,23],[12,24],[23,24],
  [23,25],[25,27],[27,29],[29,31],
  [24,26],[26,28],[28,30],[30,32]
];

// =========================
// Helpers
// =========================
const distPx = (a,b)=>Math.hypot(a._cx-b._cx, a._cy-b._cy);
const distXPx = (a,b)=>Math.abs(a._cx - b._cx);

function angleBetween(u, v) {
  const dot = u.x*v.x + u.y*v.y;
  const nu = Math.hypot(u.x,u.y), nv = Math.hypot(v.x,v.y);
  if (!nu || !nv) return 0;
  const c = Math.max(-1, Math.min(1, dot/(nu*nv)));
  return Math.acos(c) * 180/Math.PI;
}
function kneeAngle(hip, knee, ankle) {
  if (!hip || !knee || !ankle) return null;
  const u = { x: hip.x - knee.x, y: hip.y - knee.y };
  const v = { x: ankle.x - knee.x, y: ankle.y - knee.y };
  return angleBetween(u, v);
}

function mapLandmarksContain(rawLandmarks, vw, vh, cw, ch) {
  const scale = Math.min(cw / vw, ch / vh);
  const dispW = vw * scale;
  const dispH = vh * scale;
  const offX = (cw - dispW) / 2;
  const offY = (ch - dispH) / 2;

  return rawLandmarks.map(p => {
    const px = p.x * vw;
    const py = p.y * vh;
    return { ...p, _cx: offX + px * scale, _cy: offY + py * scale };
  });
}

// =========================
// EMA smoothing (CSS points)
// =========================
let smoothedCss = null;
const SMOOTH_ALPHA = 0.55; // fix (schnell, reicht)
function emaCss(cssPoints) {
  const a = SMOOTH_ALPHA;
  if (!cssPoints) return null;
  if (!smoothedCss || smoothedCss.length !== cssPoints.length) {
    smoothedCss = cssPoints.map(p => ({ ...p }));
    return smoothedCss;
  }
  for (let i = 0; i < cssPoints.length; i++) {
    const p = cssPoints[i], s = smoothedCss[i];
    s._cx = a * s._cx + (1 - a) * p._cx;
    s._cy = a * s._cy + (1 - a) * p._cy;
    if (typeof p.visibility === "number") s.visibility = p.visibility;
    if (typeof p.presence === "number") s.presence = p.presence;
  }
  return smoothedCss;
}

// =========================
// Skeleton draw
// =========================
function drawSkeletonCssPoints(cssPoints) {
  if (!toggleSkeleton.checked || !cssPoints) return;
  const lw = Math.round(Number(skelLine.value));
  const r  = Math.round(Number(skelDot.value));

  ctx.save();
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.strokeStyle = "#000";
  ctx.fillStyle = "#000";
  ctx.lineWidth = lw;

  for (const [a,b] of POSE_CONNECTIONS) {
    const pa = cssPoints[a], pb = cssPoints[b];
    if (!pa || !pb) continue;
    if (typeof pa.visibility === "number" && pa.visibility < 0.15) continue;
    if (typeof pb.visibility === "number" && pb.visibility < 0.15) continue;
    ctx.beginPath();
    ctx.moveTo(pa._cx, pa._cy);
    ctx.lineTo(pb._cx, pb._cy);
    ctx.stroke();
  }
  for (const p of cssPoints) {
    if (!p) continue;
    if (typeof p.visibility === "number" && p.visibility < 0.15) continue;
    ctx.beginPath();
    ctx.arc(p._cx, p._cy, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

// =========================
// Segmentation cache (FAST)
// =========================
const maskCanvas = document.createElement("canvas");
const maskCtx = maskCanvas.getContext("2d", { willReadFrequently: false });
let maskImageData = null;
let lastMaskBuild = 0;
let lastMaskMax = 0;
let maskReady = false;

function drawMaskContain(srcCanvas, vw, vh) {
  const scale = Math.min(CSS_W / vw, CSS_H / vh);
  const dispW = vw * scale, dispH = vh * scale;
  const offX = (CSS_W - dispW) / 2, offY = (CSS_H - dispH) / 2;
  ctx.drawImage(srcCanvas, offX, offY, dispW, dispH);
}

function rebuildMask(segMask) {
  const mw = segMask.width ?? 0;
  const mh = segMask.height ?? 0;
  if (!mw || !mh) return 0;

  if (maskCanvas.width !== mw || maskCanvas.height !== mh) {
    maskCanvas.width = mw;
    maskCanvas.height = mh;
    maskImageData = null;
  }

  const threshold = Number(silThresh.value)/100;
  const alpha = Number(silOpacity.value);
  const Aon = Math.round(255 * alpha);
  const R=255, G=215, B=0;

  let dataF=null, dataU=null;
  try { if (typeof segMask.getAsFloat32Array === "function") dataF = segMask.getAsFloat32Array(); } catch(_) {}
  if (!dataF) { try { if (typeof segMask.getAsUint8Array === "function") dataU = segMask.getAsUint8Array(); } catch(_) {} }

  if (!maskImageData || maskImageData.width !== mw || maskImageData.height !== mh) {
    maskImageData = maskCtx.createImageData(mw, mh);
  }
  const d = maskImageData.data;

  let maxv = 0;
  const N = mw*mh;

  if (dataF && dataF.length >= N) {
    for (let i=0;i<N;i++){
      const v = dataF[i]; if (v>maxv) maxv=v;
      const o=i*4;
      d[o]=R; d[o+1]=G; d[o+2]=B;
      d[o+3]=(v>=threshold)?Aon:0;
    }
  } else if (dataU && dataU.length >= N) {
    for (let i=0;i<N;i++){
      const v = dataU[i]/255; if (v>maxv) maxv=v;
      const o=i*4;
      d[o]=R; d[o+1]=G; d[o+2]=B;
      d[o+3]=(v>=threshold)?Aon:0;
    }
  }

  maskCtx.putImageData(maskImageData,0,0);
  return maxv;
}

// =========================
// TIP ENGINE (sampled)
// =========================
const recStats = {
  frames: 0,
  kneeWide: 0,
  kneeAsym: 0,
  legsBent: 0,
  handWideFrames: 0,
  armPullFrames: 0,
};
function resetRecStats(){ for(const k in recStats) recStats[k]=0; }

function getTopIssues(maxN=3){
  if (recStats.frames < 25) {
    return {
      meta: `${recStats.frames} Frames`,
      intro: "Aufnahme war sehr kurz – bitte länger filmen.",
      issues: [{title:"Aufnahme zu kurz", tip:"Bitte länger filmen (mehrere Zyklen) + stabile Perspektive."}]
    };
  }
  const p = (n)=> n/Math.max(1,recStats.frames);
  const issues=[];
  if (p(recStats.kneeWide) > 0.22) issues.push({score:p(recStats.kneeWide), title:"Knie ziehen zu breit an", tip:"Knie schmal anziehen – Rückholen kompakt."});
  if (filmingPreset.value==="back45" && p(recStats.kneeAsym) > 0.22) issues.push({score:p(recStats.kneeAsym), title:"Beinschere (Asymmetrie)", tip:"Beinbewegung links/rechts wirkte asymmetrisch."});
  const pullDen = Math.max(1, recStats.armPullFrames);
  const handWideShare = recStats.handWideFrames / pullDen;
  if (handWideShare > 0.18) issues.push({score:handWideShare, title:"Armzug sehr breit", tip:"Hände weniger weit nach außen öffnen."});
  issues.sort((a,b)=>b.score-a.score);
  return { meta:`${recStats.frames} Frames`, intro:"In dieser Aufnahme waren folgende Punkte auffällig:", issues:issues.slice(0,maxN) };
}

function showTips(){
  tipsBox.style.display="none";
  hintList.innerHTML="";
  hintText.textContent="";
  hintMeta.textContent="";

  const pack=getTopIssues(3);
  if(!pack.issues || pack.issues.length===0) return;

  hintMeta.textContent=pack.meta;
  hintText.textContent=pack.intro;
  for(const it of pack.issues){
    const li=document.createElement("li");
    li.innerHTML=`<b>${it.title}</b> – ${it.tip}`;
    hintList.appendChild(li);
  }
  tipsBox.style.display="block";
}

// simple heuristics (cheap)
function handTooWide(raw){
  const ls=raw[11], rs=raw[12], lw=raw[15], rw=raw[16];
  if(!ls||!rs||!lw||!rw) return false;
  const shW=Math.abs(ls.x-rs.x);
  const hW=Math.abs(lw.x-rw.x);
  if(shW<1e-4) return false;
  return (hW/shW) > 2.5;
}
function kneeTooWide(raw){
  const ls=raw[11], rs=raw[12], lk=raw[25], rk=raw[26];
  if(!ls||!rs||!lk||!rk) return false;
  const shW=Math.abs(ls.x-rs.x);
  const kW=Math.abs(lk.x-rk.x);
  if(shW<1e-4) return false;
  return (kW/shW) > 1.55;
}
function kneeAsym(raw){
  const lh=raw[23], rh=raw[24], lk=raw[25], rk=raw[26], la=raw[27], ra=raw[28];
  const aL=kneeAngle(lh,lk,la);
  const aR=kneeAngle(rh,rk,ra);
  if(aL==null||aR==null) return false;
  return Math.abs(aL-aR) > 25;
}
function isPullPhase(raw){
  // billig: Hände unter Schulter + Ellbogen angewinkelt
  const ls=raw[11], rs=raw[12], le=raw[13], re=raw[14], lw=raw[15], rw=raw[16];
  if(!ls||!rs) return false;
  const shY=(ls.y+rs.y)/2;
  const eL=(ls&&le&&lw)?angleBetween({x:ls.x-le.x,y:ls.y-le.y},{x:lw.x-le.x,y:lw.y-le.y}):180;
  const eR=(rs&&re&&rw)?angleBetween({x:rs.x-re.x,y:rs.y-re.y},{x:rw.x-re.x,y:rw.y-re.y}):180;
  const wDown = (lw&&lw.y>shY+0.03) || (rw&&rw.y>shY+0.03);
  const elbowBent = (eL<165) || (eR<165);
  return wDown && elbowBent;
}

// =========================
// Recording
// =========================
let recorder=null, recordedChunks=[], lastBlob=null;
let isRecording=false;

function pickMimeType(){
  const candidates=[
    'video/mp4;codecs="avc1.42E01E"',
    "video/mp4",
    'video/webm;codecs="vp8"',
    "video/webm"
  ];
  if(!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
  for(const t of candidates){ try{ if(MediaRecorder.isTypeSupported(t)) return t; } catch(_){} }
  return "";
}
function startRecordingCanvas(){
  recordedChunks=[]; lastBlob=null; btnShare.disabled=true;
  isRecording=true;
  resetRecStats();
  tipsBox.style.display="none";

  const s = canvas.captureStream(15); // Recording fps ok
  const mt = pickMimeType();
  try{ recorder=new MediaRecorder(s, mt?{mimeType:mt}:undefined); }
  catch(_){ recorder=new MediaRecorder(s); }

  recorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
  recorder.onstop=()=>{
    isRecording=false;
    const type = recorder.mimeType || mt || "video/webm";
    lastBlob = new Blob(recordedChunks,{type});
    btnShare.disabled = !lastBlob;
    setStatus("Aufnahme fertig.");
    showTips(); // ✅ zuverlässig
  };
  recorder.start(200);
  setStatus("Aufnahme läuft…");
}
function stopRecordingCanvas(){ if(recorder && recorder.state!=="inactive") recorder.stop(); }

async function shareOrDownload(){
  if(!lastBlob){ setStatus("Kein Video vorhanden."); return; }
  const type = lastBlob.type || "video/webm";
  const ext  = type.includes("mp4") ? "mp4" : "webm";
  const name = `bewegungsanalyse_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
  const url = URL.createObjectURL(lastBlob);
  const a = document.createElement("a");
  a.href=url; a.download=name; a.rel="noopener";
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url),8000);
  setStatus("Speichern gestartet.");
}

// =========================
// MediaPipe
// =========================
let landmarker=null;
let running=false;
let rafId=null;
let stream=null;
let isBackCamera=true;

const POSE_TASK_URL =
  "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task";

async function createLandmarker(){
  setStatus("Lade Tasks-WASM …");
  const fileset = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
  );
  setStatus("Lade Pose Landmarker …");
  landmarker = await PoseLandmarker.createFromOptions(fileset, {
    baseOptions: { modelAssetPath: POSE_TASK_URL },
    runningMode: "VIDEO",
    numPoses: 1,
    outputSegmentationMasks: true,
    minPoseDetectionConfidence: 0.50,
    minPosePresenceConfidence: 0.50,
    minTrackingConfidence: 0.55,
  });
}

async function startCamera(){
  stopCamera();
  stream = await navigator.mediaDevices.getUserMedia({
    audio:false,
    video:{
      facingMode: isBackCamera ? "environment" : "user",
      width:{ideal:1280},
      height:{ideal:720}
    }
  });
  video.srcObject = stream;
  await new Promise((resolve)=>{
    const done=()=>resolve();
    if(video.readyState>=1) return done();
    video.onloadedmetadata = done;
  });
  await video.play();
  await new Promise((resolve)=>{
    const check=()=> (video.videoWidth>0 && video.videoHeight>0) ? resolve() : requestAnimationFrame(check);
    check();
  });
}
function stopCamera(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.srcObject=null;
}

// =========================
// Loop (fast) + throttles
// =========================
let lastMaskTick = 0;
let lastTipsTick = 0;

function tick(){
  if(!running || !landmarker) return;

  const now = performance.now();

  // clear bg
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, CSS_W, CSS_H);

  if(video.videoWidth===0 || video.videoHeight===0){
    rafId=requestAnimationFrame(tick);
    return;
  }

  const result = landmarker.detectForVideo(video, now);
  const raw = (result?.landmarks?.[0]?.length) ? result.landmarks[0] : null;

  // ==== MASK: rebuild only MASK_FPS ====
  if (toggleSilhouette.checked) {
    const mask = result?.segmentationMasks?.[0] || null;
    const interval = 1000 / MASK_FPS;

    if (mask && (now - lastMaskBuild) >= interval) {
      lastMaskMax = rebuildMask(mask);
      maskReady = true;
      lastMaskBuild = now;
    }
    if (maskReady) {
      drawMaskContain(maskCanvas, video.videoWidth, video.videoHeight);
    }
  }

  // ==== SKELETON (every frame) ====
  if (raw) {
    const cssPoints = emaCss(mapLandmarksContain(raw, video.videoWidth, video.videoHeight, CSS_W, CSS_H));
    drawSkeletonCssPoints(cssPoints);

    // ==== TIPS: compute only TIPS_FPS (cheap) ====
    if (isRecording && (now - lastTipsTick) >= (1000 / TIPS_FPS)) {
      recStats.frames++;

      if (kneeTooWide(raw)) recStats.kneeWide++;
      if (filmingPreset.value==="back45" && kneeAsym(raw)) recStats.kneeAsym++;

      const pull = isPullPhase(raw);
      if (pull) {
        recStats.armPullFrames++;
        if (handTooWide(raw)) recStats.handWideFrames++;
      }

      lastTipsTick = now;
    }
  }

  rafId=requestAnimationFrame(tick);
}

// =========================
// Buttons
// =========================
btnInit.addEventListener("click", async ()=>{
  try{
    btnInit.disabled=true;
    applyLayoutFromOrientation();
    setStatus("Initialisiere …");
    await startCamera();
    await createLandmarker();

    running=true;
    btnSwitch.disabled=false;
    btnRec.disabled=false;
    btnReset.disabled=false;

    // reset perf timers
    lastMaskBuild = 0;
    lastTipsTick = 0;
    maskReady = false;

    setStatus("bereit.");
    rafId=requestAnimationFrame(tick);
  } catch(e){
    console.error(e);
    setStatus("Fehler: " + (e?.message || String(e)));
    btnInit.disabled=false;
  }
});

btnSwitch.addEventListener("click", async ()=>{
  try{
    btnSwitch.disabled=true;
    running=false;
    if(rafId) cancelAnimationFrame(rafId);

    isBackCamera=!isBackCamera;
    await startCamera();

    smoothedCss=null;
    maskReady=false;
    lastMaskBuild=0;

    running=true;
    rafId=requestAnimationFrame(tick);
    btnSwitch.disabled=false;
    setStatus("Kamera gewechselt.");
  } catch(e){
    console.error(e);
    setStatus("Kamerawechsel-Fehler: " + (e?.message || String(e)));
    running=true;
    rafId=requestAnimationFrame(tick);
    btnSwitch.disabled=false;
  }
});

btnRec.addEventListener("click", ()=>{
  btnRec.disabled=true;
  btnStop.disabled=false;
  startRecordingCanvas();
});

btnStop.addEventListener("click", ()=>{
  btnStop.disabled=true;
  stopRecordingCanvas();
  btnRec.disabled=false;
});

btnShare.addEventListener("click",(e)=>{ e.preventDefault(); shareOrDownload(); });

btnReset.addEventListener("click", ()=>{
  resetRecStats();
  tipsBox.style.display="none";
  setStatus("Zurückgesetzt.");
});
</script>
</body>
</html>
