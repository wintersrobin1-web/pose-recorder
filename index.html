<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Swim Pose Recorder (Silhouette + Gleit-Timer + Kamerawechsel)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    video, canvas { max-width: 100%; width: 480px; height: auto; border: 1px solid #ddd; border-radius: 10px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button.primary { border-color: #111; }
    button:disabled { opacity: 0.5; }
    label { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; }
    select { padding: 9px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    .hint { color: #555; font-size: 14px; line-height: 1.4; max-width: 980px; }
    .small { font-size: 13px; color: #666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>

  <!-- MediaPipe (klassisch) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
</head>

<body>
  <h1>Swim Pose Recorder (Skelett + Silhouette + Timer)</h1>
  <p class="hint">
    Links: Live-Kamera (nur zur Erkennung). Rechts: Canvas (wird gespeichert) mit hellblauem Hintergrund, anonymem Umriss,
    Skelett und Timer/Slots. Kamera kann Front/Rück umgeschaltet werden.
  </p>

  <div class="row">
    <button id="btnInit" class="primary">Kamera aktivieren</button>
    <button id="btnSwitch" disabled>Kamera wechseln (Rück)</button>
    <button id="btnRec" disabled>Aufnahme starten</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnShare" disabled>Teilen/Speichern</button>
    <button id="btnReset" disabled>Slots zurücksetzen</button>
  </div>

  <div class="row">
    <label><input type="checkbox" id="toggleSilhouette" checked /> Silhouette (anonym)</label>
    <label><input type="checkbox" id="toggleSpine" checked /> Mittelachse</label>
    <label><input type="checkbox" id="toggleTimer" checked /> Timer/Slots</label>

    <span class="small">Timer-Trigger:</span>
    <select id="triggerMode" title="Timer-Trigger">
      <option value="auto" selected>Auto</option>
      <option value="overhead">Hände über Kopf</option>
      <option value="forward">Arme nach vorn (seitlich filmen)</option>
    </select>
  </div>

  <div class="row">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <p class="hint mono" id="status">Status: bereit</p>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const btnInit = document.getElementById("btnInit");
    const btnSwitch = document.getElementById("btnSwitch");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const btnReset = document.getElementById("btnReset");
    const statusEl = document.getElementById("status");

    const toggleSilhouette = document.getElementById("toggleSilhouette");
    const toggleSpine = document.getElementById("toggleSpine");
    const toggleTimer = document.getElementById("toggleTimer");
    const triggerMode = document.getElementById("triggerMode");

    function setStatus(s) { statusEl.textContent = "Status: " + s; }

    // -----------------------------
    // Canvas Look
    // -----------------------------
    const BG = "#bfe7ff";                  // hellblau
    const SIL = "rgba(20, 70, 120, 0.35)"; // Silhouette-Füllung
    const SIL_EDGE = "rgba(20, 70, 120, 0.65)";

    function drawBackground() {
      ctx.save();
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    // -----------------------------
    // Recording (Canvas -> Video)
    // -----------------------------
    let recorder = null;
    let recordedChunks = [];
    let lastBlob = null;

    function pickMimeType() {
      const candidates = ["video/webm;codecs=vp8", "video/webm", "video/mp4"];
      if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
      for (const t of candidates) if (MediaRecorder.isTypeSupported(t)) return t;
      return "";
    }

    function startRecording() {
      recordedChunks = [];
      lastBlob = null;
      btnShare.disabled = true;

      const fps = 15;
      const stream = canvas.captureStream(fps);

      const mimeType = pickMimeType();
      const options = mimeType ? { mimeType } : undefined;

      recorder = new MediaRecorder(stream, options);
      recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
      recorder.onstop = () => {
        const type = (recorder && recorder.mimeType) ? recorder.mimeType : "video/webm";
        lastBlob = new Blob(recordedChunks, { type });
        btnShare.disabled = !lastBlob;
        setStatus("Aufnahme fertig. (MP4 via Kurzbefehl-Konvertierung)");
      };

      recorder.start(200);
      setStatus("Aufnahme läuft…");
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") recorder.stop();
    }

    async function shareOrDownload() {
      if (!lastBlob) return;

      const ext = lastBlob.type.includes("mp4") ? "mp4" : "webm";
      const fileName = `pose_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
      const file = new File([lastBlob], fileName, { type: lastBlob.type });

      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: "Pose-Aufnahme" });
        setStatus("Geteilt/gespeichert.");
        return;
      }

      const url = URL.createObjectURL(lastBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Download gestartet.");
    }

    // -----------------------------
    // Pose + Camera
    // -----------------------------
    let pose = null;
    let cam = null;
    let isBackCamera = true; // default: Rückkamera

    function resizeCanvasToVideo() {
      canvas.width = video.videoWidth || 1280;
      canvas.height = video.videoHeight || 720;
    }

    function stopCameraHard() {
      // camera_utils Camera nutzt intern getUserMedia; stop() ist je nach Version vorhanden.
      try { if (cam && cam.stop) cam.stop(); } catch (_) {}

      // zusätzlich: falls ein Stream am Video hängt, Tracks beenden
      try {
        const s = video.srcObject;
        if (s && s.getTracks) s.getTracks().forEach(t => t.stop());
      } catch (_) {}
      video.srcObject = null;
    }

    async function startCamera(facingMode) {
      stopCameraHard();

      cam = new Camera(video, {
        onFrame: async () => { await pose.send({ image: video }); },
        width: 1280,
        height: 720,
        facingMode // "environment" oder "user"
      });

      await cam.start();
      resizeCanvasToVideo();
    }

    async function initAll() {
      btnInit.disabled = true;
      setStatus("initialisiere…");

      pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        selfieMode: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults(drawOutput);

      await startCamera(isBackCamera ? "environment" : "user");

      btnSwitch.disabled = false;
      btnRec.disabled = false;
      btnReset.disabled = false;

      btnSwitch.textContent = "Kamera wechseln (" + (isBackCamera ? "Rück" : "Front") + ")";
      setStatus("bereit.");
    }

    // -----------------------------
    // Silhouette + Skelett
    // -----------------------------
    function midPoint(a, b) { return { x: (a.x+b.x)/2, y: (a.y+b.y)/2 }; }

    function drawSilhouetteFromLandmarks(landmarks) {
      if (!toggleSilhouette.checked) return;

      const n  = landmarks[0];
      const ls = landmarks[11], rs = landmarks[12];
      const le = landmarks[13], re = landmarks[14];
      const lw = landmarks[15], rw = landmarks[16];
      const lh = landmarks[23], rh = landmarks[24];
      const lk = landmarks[25], rk = landmarks[26];
      const la = landmarks[27], ra = landmarks[28];

      if (!ls || !rs || !lh || !rh) return;

      const pts = [];
      if (n) pts.push(n);
      pts.push(ls, rs);
      if (re) pts.push(re);
      if (rw) pts.push(rw);
      pts.push(rh);
      if (rk) pts.push(rk);
      if (ra) pts.push(ra);
      if (la) pts.push(la);
      if (lk) pts.push(lk);
      pts.push(lh);
      if (lw) pts.push(lw);
      if (le) pts.push(le);

      const pix = pts.filter(Boolean).map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height }));
      if (pix.length < 4) return;

      ctx.save();
      ctx.fillStyle = SIL;
      ctx.strokeStyle = SIL_EDGE;
      ctx.lineWidth = 6;
      ctx.lineJoin = "round";
      ctx.beginPath();
      ctx.moveTo(pix[0].x, pix[0].y);
      for (let i = 1; i < pix.length; i++) ctx.lineTo(pix[i].x, pix[i].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawMidSpine(landmarks) {
      if (!toggleSpine.checked) return;
      const ls = landmarks[11], rs = landmarks[12], lh = landmarks[23], rh = landmarks[24];
      if (!ls || !rs || !lh || !rh) return;

      const ms = midPoint(ls, rs);
      const mh = midPoint(lh, rh);

      const x1 = ms.x * canvas.width, y1 = ms.y * canvas.height;
      const x2 = mh.x * canvas.width, y2 = mh.y * canvas.height;

      ctx.save();
      ctx.lineWidth = 14;
      ctx.lineCap = "round";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "rgba(0,0,0,0.65)";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }

    // -----------------------------
    // Timer / 4 Slots
    // -----------------------------
    const glideTimes = [];
    let glideActive = false;
    let glideStart = 0;
    let currentElapsed = 0;
    let poseStableSince = null;
    let poseLostSince = null;

    function formatMs(ms) { return (ms / 1000).toFixed(3) + " s"; }

    // Mode 1: Hände über Kopf (Beckenrand/Stand)
    function isOverhead(landmarks) {
      const ls = landmarks[11], rs = landmarks[12];
      const le = landmarks[13], re = landmarks[14];
      const lw = landmarks[15], rw = landmarks[16];
      if (!ls || !rs || !le || !re || !lw || !rw) return false;

      const shoulderY = (ls.y + rs.y) / 2;
      const wristsUp = (lw.y < shoulderY - 0.03) && (rw.y < shoulderY - 0.03);
      const elbowsUp = (le.y < shoulderY + 0.02) && (re.y < shoulderY + 0.02);
      const wristsClose = Math.abs(lw.x - rw.x) < 0.35;

      return wristsUp && elbowsUp && wristsClose;
    }

    // Mode 2: Arme nach vorn (seitliche Schwimmaufnahme)
    // Idee: Handgelenke deutlich "weg" von den Schultern (großer Abstand),
    // Handgelenke nahe beieinander (Streamline), Ellenbogen relativ auf der Linie Schulter->Hand.
    function dist(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function isForwardStreamline(landmarks) {
      const ls = landmarks[11], rs = landmarks[12];
      const le = landmarks[13], re = landmarks[14];
      const lw = landmarks[15], rw = landmarks[16];
      if (!ls || !rs || !le || !re || !lw || !rw) return false;

      // "Arme lang": Handgelenk weit von Schulter
      const leftArmLen = dist(ls, lw);
      const rightArmLen = dist(rs, rw);
      const armsExtended = (leftArmLen > 0.33) && (rightArmLen > 0.33);

      // Handgelenke relativ nah zueinander (Streamline)
      const wristsClose = dist(lw, rw) < 0.25;

      // Ellenbogen nicht stark abgeknickt: Ellenbogen nahe der Verbindung Schulter->Hand (kollinear-ish)
      // Wir nutzen: dist(shoulder,elbow)+dist(elbow,wrist) ~ dist(shoulder,wrist)
      const leftStraight = (dist(ls, le) + dist(le, lw)) <= (dist(ls, lw) * 1.12);
      const rightStraight = (dist(rs, re) + dist(re, rw)) <= (dist(rs, rw) * 1.12);

      return armsExtended && wristsClose && leftStraight && rightStraight;
    }

    function isStreamline(landmarks) {
      const mode = triggerMode.value;

      if (mode === "overhead") return isOverhead(landmarks);
      if (mode === "forward") return isForwardStreamline(landmarks);

      // Auto:
      // Wenn "overhead" erkennbar ist, nutze das. Sonst nutze "forward".
      if (isOverhead(landmarks)) return true;
      return isForwardStreamline(landmarks);
    }

    function updateTimer(landmarks, now) {
      if (!toggleTimer.checked) {
        glideActive = false;
        poseStableSince = null;
        poseLostSince = null;
        currentElapsed = 0;
        return;
      }

      const inPose = isStreamline(landmarks);

      if (!glideActive) {
        currentElapsed = 0;
        if (inPose && glideTimes.length < 4) {
          if (poseStableSince === null) poseStableSince = now;
          if (now - poseStableSince >= 220) { // bewusst etwas stabiler
            glideActive = true;
            glideStart = now;
            poseLostSince = null;
          }
        } else {
          poseStableSince = null;
        }
        return;
      }

      currentElapsed = now - glideStart;

      if (!inPose) {
        if (poseLostSince === null) poseLostSince = now;
        if (now - poseLostSince >= 180) {
          glideActive = false;
          poseStableSince = null;
          poseLostSince = null;
          const dur = now - glideStart;
          glideTimes.push(dur);
          if (glideTimes.length > 4) glideTimes.length = 4;
          currentElapsed = 0;
        }
      } else {
        poseLostSince = null;
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function drawTimerOverlay(landmarks) {
      if (!toggleTimer.checked) return;

      const inPose = landmarks ? isStreamline(landmarks) : false;

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.strokeStyle = "rgba(255,255,255,0.65)";
      ctx.lineWidth = 2;
      const x = 14, y = 14, w = 420, h = 175;
      roundRect(ctx, x, y, w, h, 14);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "white";
      ctx.shadowBlur = 8;
      ctx.shadowColor = "rgba(0,0,0,0.7)";

      ctx.font = "700 40px system-ui";
      ctx.fillText(glideActive ? formatMs(currentElapsed) : "0.000 s", x + 14, y + 48);

      ctx.font = "600 16px system-ui";
      const modeLabel = (triggerMode.value === "auto") ? "Auto" : (triggerMode.value === "overhead" ? "Hände über Kopf" : "Arme nach vorn");
      const st = glideActive ? "Gleitphase: läuft"
               : (glideTimes.length >= 4 ? "Slots voll (4/4)" : (inPose ? "Pose erkannt (Start in 0.22s)" : "Warte auf Pose"));
      ctx.fillText(`Trigger: ${modeLabel}  |  ${st}`, x + 14, y + 76);

      ctx.font = "18px system-ui";
      for (let i = 0; i < 4; i++) {
        const t = glideTimes[i] != null ? formatMs(glideTimes[i]) : "—";
        ctx.fillText(`Slot ${i+1}: ${t}`, x + 14, y + 105 + i * 18);
      }
      ctx.restore();
    }

    // -----------------------------
    // Main render callback
    // -----------------------------
    function drawOutput(results) {
      drawBackground();

      if (!results || !results.poseLandmarks) {
        drawTimerOverlay(null);
        return;
      }

      const lms = results.poseLandmarks;

      // Silhouette
      drawSilhouetteFromLandmarks(lms);

      // Skelett
      const drawConnectorsFn = window.drawConnectors;
      const drawLandmarksFn = window.drawLandmarks;
      const connections = window.POSE_CONNECTIONS;

      if (drawConnectorsFn && drawLandmarksFn && connections) {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(0,0,0,0.65)";
        drawConnectorsFn(ctx, lms, connections, { lineWidth: 14 });
        drawLandmarksFn(ctx, lms, { radius: 8 });
        ctx.restore();
      }

      // Mittelachse
      drawMidSpine(lms);

      // Timer update + overlay (im Video)
      const now = performance.now();
      updateTimer(lms, now);
      drawTimerOverlay(lms);
    }

    // -----------------------------
    // UI wiring
    // -----------------------------
    btnInit.addEventListener("click", async () => {
      try {
        await initAll();
      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + (err && err.message ? err.message : String(err)));
        btnInit.disabled = false;
      }
    });

    btnSwitch.addEventListener("click", async () => {
      try {
        btnSwitch.disabled = true;
        isBackCamera = !isBackCamera;
        await startCamera(isBackCamera ? "environment" : "user");
        btnSwitch.textContent = "Kamera wechseln (" + (isBackCamera ? "Rück" : "Front") + ")";
        btnSwitch.disabled = false;
        setStatus("Kamera gewechselt.");
      } catch (err) {
        console.error(err);
        setStatus("Kamerawechsel-Fehler: " + (err && err.message ? err.message : String(err)));
        btnSwitch.disabled = false;
      }
    });

    btnRec.addEventListener("click", () => {
      btnRec.disabled = true;
      btnStop.disabled = false;
      startRecording();
    });

    btnStop.addEventListener("click", () => {
      btnStop.disabled = true;
      stopRecording();
      btnRec.disabled = false;
    });

    btnShare.addEventListener("click", () => shareOrDownload());

    btnReset.addEventListener("click", () => {
      glideTimes.length = 0;
      glideActive = false;
      poseStableSince = null;
      poseLostSince = null;
      currentElapsed = 0;
      setStatus("Slots zurückgesetzt.");
    });
  </script>
</body>
</html>
