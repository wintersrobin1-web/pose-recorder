<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bewegungsanalyse Recorder | anonym (Skelett + HWS-Achse + Timer)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    video, canvas { max-width: 100%; border: 1px solid #ddd; border-radius: 10px; }
    video { width: 360px; height: auto; background:#000; }
    canvas { width: 360px; height: auto; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button.primary { border-color: #111; }
    button:disabled { opacity: 0.5; }
    label { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; }
    select { padding: 9px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    details { border: 1px solid #ddd; border-radius: 10px; padding: 10px 12px; max-width: 1100px; }
    summary { cursor: pointer; font-weight: 600; }
    .hint { color: #555; font-size: 14px; line-height: 1.4; max-width: 1100px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .rangeWrap { display:flex; align-items:center; gap:10px; padding: 8px 10px; border:1px solid #ddd; border-radius: 10px; margin-top: 10px; flex-wrap: wrap; }
    .rangeWrap span { min-width: 170px; font-size: 13px; color:#666; }
    .small { font-size: 13px; color:#666; min-width: 64px; text-align:right; }
  </style>
</head>

<body>
  <h1>Bewegungsanalyse Recorder (anonym)</h1>
  <p class="hint">
    Output-Video enthält nur Hintergrund (hellblau) + Skelett + HWS-Achse + Timer/Slots.
    Links ist nur Input. Hochkant/Querformat wechseln automatisch.
  </p>

  <div class="row">
    <button id="btnInit" class="primary">Kamera aktivieren</button>
    <button id="btnSwitch" disabled>Kamera wechseln (Rück)</button>
    <button id="btnRec" disabled>Aufnahme starten</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnShare" disabled>Teilen/Speichern</button>
    <button id="btnReset" disabled>Slots zurücksetzen</button>
  </div>

  <div class="row">
    <label><input type="checkbox" id="toggleSkeleton" checked /> Skelett</label>
    <label><input type="checkbox" id="toggleAxis" checked /> Achse Kopf–Rumpf (HWS)</label>
    <label><input type="checkbox" id="toggleAxisColor" checked /> HWS-Ampel (grün/rot)</label>
    <label><input type="checkbox" id="toggleTimer" checked /> Timer: Brust – Gleitphase</label>

    <select id="filmingPreset" title="Aufnahmeposition">
      <option value="stand" selected>Stand-Test (Beckenrand)</option>
      <option value="side45">45° seitlich</option>
      <option value="back45">45° von hinten</option>
    </select>
  </div>

  <details>
    <summary>Erweiterte Einstellungen (optional)</summary>

    <div class="rangeWrap">
      <span>Skelett-Linienstärke</span>
      <input id="skelLine" type="range" min="1" max="10" step="1" value="3">
      <span id="skelLineVal" class="small">3</span>
    </div>

    <div class="rangeWrap">
      <span>Gelenkpunkte (Radius)</span>
      <input id="skelDot" type="range" min="1" max="10" step="1" value="4">
      <span id="skelDotVal" class="small">4</span>
    </div>

    <div class="rangeWrap">
      <span>Detection (min)</span>
      <input id="detConf" type="range" min="0.3" max="0.95" step="0.01" value="0.50">
      <span id="detVal" class="small">0.50</span>
    </div>

    <div class="rangeWrap">
      <span>Presence (min)</span>
      <input id="presConf" type="range" min="0.3" max="0.95" step="0.01" value="0.50">
      <span id="presVal" class="small">0.50</span>
    </div>

    <div class="rangeWrap">
      <span>Tracking (min)</span>
      <input id="trackConf" type="range" min="0.3" max="0.95" step="0.01" value="0.55">
      <span id="trackVal" class="small">0.55</span>
    </div>

    <div class="rangeWrap">
      <span>Glättung (EMA)</span>
      <input id="smooth" type="range" min="0" max="0.9" step="0.05" value="0.60">
      <span id="smoothVal" class="small">0.60</span>
    </div>

    <p class="hint">
      HWS-Ampel: grün = Kopf/Hals in Linie mit Rumpf (neutral), rot = deutlich gebeugt/überstreckt.
    </p>
  </details>

  <div class="row">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <p class="hint mono" id="status">Status: bereit</p>

  <script type="module">
    import { FilesetResolver, PoseLandmarker }
      from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // ---------- DOM ----------
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const btnInit = document.getElementById("btnInit");
    const btnSwitch = document.getElementById("btnSwitch");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const btnReset = document.getElementById("btnReset");

    const toggleSkeleton = document.getElementById("toggleSkeleton");
    const toggleAxis = document.getElementById("toggleAxis");
    const toggleAxisColor = document.getElementById("toggleAxisColor");
    const toggleTimer = document.getElementById("toggleTimer");
    const filmingPreset = document.getElementById("filmingPreset");

    const skelLine  = document.getElementById("skelLine");
    const skelDot   = document.getElementById("skelDot");
    const detConf = document.getElementById("detConf");
    const presConf = document.getElementById("presConf");
    const trackConf = document.getElementById("trackConf");
    const smooth = document.getElementById("smooth");

    const skelLineVal   = document.getElementById("skelLineVal");
    const skelDotVal    = document.getElementById("skelDotVal");
    const detVal = document.getElementById("detVal");
    const presVal = document.getElementById("presVal");
    const trackVal = document.getElementById("trackVal");
    const smoothVal = document.getElementById("smoothVal");

    const statusEl = document.getElementById("status");
    const setStatus = (s) => statusEl.textContent = "Status: " + s;

    function bindSlider(el, out, fmt=(v)=>Number(v).toFixed(2)) {
      const update = () => out.textContent = fmt(el.value);
      el.addEventListener("input", update);
      update();
    }
    bindSlider(skelLine,   skelLineVal,   v => String(Math.round(Number(v))));
    bindSlider(skelDot,    skelDotVal,    v => String(Math.round(Number(v))));
    bindSlider(detConf, detVal);
    bindSlider(presConf, presVal);
    bindSlider(trackConf, trackVal);
    bindSlider(smooth, smoothVal, v => Number(v).toFixed(2));

    // ---------- Orientation + HiDPI ----------
    function isPortraitUI() {
      const so = screen.orientation && screen.orientation.type;
      if (typeof so === "string") return so.includes("portrait");
      if (window.matchMedia) return window.matchMedia("(orientation: portrait)").matches;
      return window.innerHeight >= window.innerWidth;
    }

    let CSS_W = 360, CSS_H = 640;
    function setupHiDPICanvas(cssW, cssH) {
      CSS_W = cssW; CSS_H = cssH;
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";

      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);

      // draw in CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }

    function applyLayoutFromOrientation() {
      if (isPortraitUI()) setupHiDPICanvas(360, 640);
      else setupHiDPICanvas(640, 360);
      setStatus("Ausrichtung: " + (isPortraitUI() ? "Hochformat" : "Querformat"));
    }
    window.addEventListener("resize", applyLayoutFromOrientation);
    window.addEventListener("orientationchange", applyLayoutFromOrientation);

    // ---------- Background ----------
    const BG = "#bfe7ff";

    // ---------- Connections ----------
    const POSE_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,7],
      [0,4],[4,5],[5,6],[6,8],
      [9,10],
      [11,12],
      [11,13],[13,15],[15,17],[15,19],[15,21],[17,19],
      [12,14],[14,16],[16,18],[16,20],[16,22],[18,20],
      [11,23],[12,24],[23,24],
      [23,25],[25,27],[27,29],[29,31],
      [24,26],[26,28],[28,30],[30,32]
    ];

    // ---------- Contain mapping ----------
    function containRect(vw, vh, cw, ch) {
      const scale = Math.min(cw / vw, ch / vh);
      const dispW = vw * scale;
      const dispH = vh * scale;
      const offX = (cw - dispW) / 2;
      const offY = (ch - dispH) / 2;
      return { offX, offY, dispW, dispH, scale };
    }

    function mapLandmarksToCss(rawLandmarks, vw, vh, cw, ch, mirrorX) {
      const { offX, offY, scale } = containRect(vw, vh, cw, ch);
      return rawLandmarks.map(p => {
        const nx = mirrorX ? (1 - p.x) : p.x;
        return {
          ...p,
          _cx: offX + (nx * vw) * scale,
          _cy: offY + (p.y * vh) * scale,
        };
      });
    }

    // ---------- EMA smoothing ----------
    let smoothed = null;
    function ema(cssPoints) {
      const a = Number(smooth.value);
      if (!cssPoints) return null;

      if (!smoothed || smoothed.length !== cssPoints.length) {
        smoothed = cssPoints.map(p => ({...p}));
        return smoothed;
      }
      for (let i=0;i<cssPoints.length;i++){
        const p = cssPoints[i], s = smoothed[i];
        s._cx = a*s._cx + (1-a)*p._cx;
        s._cy = a*s._cy + (1-a)*p._cy;
        s.z = a*(s.z ?? (p.z ?? 0)) + (1-a)*(p.z ?? 0);
        if (typeof p.visibility === "number") s.visibility = p.visibility;
        if (typeof p.presence === "number") s.presence = p.presence;
      }
      return smoothed;
    }

    // ---------- Skeleton drawing ----------
    function drawSkeletonCssPoints(cssPoints){
      if(!toggleSkeleton.checked || !cssPoints) return;

      const lw = Math.round(Number(skelLine.value));
      const r  = Math.round(Number(skelDot.value));

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "#000";
      ctx.fillStyle = "#000";
      ctx.lineWidth = lw;

      for(const [a,b] of POSE_CONNECTIONS){
        const pa = cssPoints[a], pb = cssPoints[b];
        if(!pa || !pb) continue;
        if (typeof pa.visibility === "number" && pa.visibility < 0.2) continue;
        if (typeof pb.visibility === "number" && pb.visibility < 0.2) continue;

        ctx.beginPath();
        ctx.moveTo(pa._cx, pa._cy);
        ctx.lineTo(pb._cx, pb._cy);
        ctx.stroke();
      }

      for(const p of cssPoints){
        if(!p) continue;
        if (typeof p.visibility === "number" && p.visibility < 0.2) continue;
        ctx.beginPath();
        ctx.arc(p._cx, p._cy, r, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }

    // ---------- HWS / Kopf-Rumpf-Achse ----------
    function angleDegBetweenVectors(ax, ay, bx, by) {
      const da = Math.hypot(ax, ay);
      const db = Math.hypot(bx, by);
      if (!da || !db) return null;
      const dot = (ax*bx + ay*by) / (da*db);
      const clamped = Math.max(-1, Math.min(1, dot));
      return Math.acos(clamped) * (180 / Math.PI);
    }

    // neutral, wenn Kopf-Achse & Rumpf-Achse nahezu kollinear (Winkel nahe 180°)
    const NECK_NEUTRAL_TOL_DEG = 18; // <- bei Bedarf 15..25 testen

    function drawHeadTorsoAxis(cssPoints) {
      if (!toggleAxis.checked || !cssPoints) return;

      const nose = cssPoints[0];
      const ls = cssPoints[11], rs = cssPoints[12];
      const lh = cssPoints[23], rh = cssPoints[24];
      if (!ls || !rs || !lh || !rh) return;

      const sh = { x: (ls._cx + rs._cx)/2, y: (ls._cy + rs._cy)/2 };
      const hp = { x: (lh._cx + rh._cx)/2, y: (lh._cy + rh._cy)/2 };

      // Vektoren (Schultermitte als Ursprung):
      // Kopf: Schulter -> Nose
      // Rumpf: Schulter -> Hüfte
      let headVec = null;
      if (nose && !(typeof nose.visibility === "number" && nose.visibility < 0.2)) {
        headVec = { x: (nose._cx - sh.x), y: (nose._cy - sh.y) };
      }
      const torsoVec = { x: (hp.x - sh.x), y: (hp.y - sh.y) };

      // Standardfarbe (wenn Ampel aus oder Nose fehlt)
      let colHead = "rgba(0,0,0,0.55)";
      let colTorso = "rgba(0,0,0,0.85)";

      if (toggleAxisColor.checked && headVec) {
        const ang = angleDegBetweenVectors(headVec.x, headVec.y, torsoVec.x, torsoVec.y);
        // neutral => Winkel nahe 180°
        const dev = (ang == null) ? null : Math.abs(180 - ang);

        const ok = (dev != null && dev <= NECK_NEUTRAL_TOL_DEG);
        // grün/rot für beide Achsen, aber Kopf etwas transparenter
        colTorso = ok ? "rgba(0,170,0,0.95)" : "rgba(220,0,0,0.95)";
        colHead  = ok ? "rgba(0,170,0,0.65)" : "rgba(220,0,0,0.65)";
      }

      const lwBase = Math.max(2, Math.round(Number(skelLine.value) * 0.8));
      const lwHead = Math.max(2, Math.round(Number(skelLine.value) * 0.6));
      const rMid   = Math.max(2, Math.round(Number(skelDot.value) * 0.8));

      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      // Rumpfachse (Schultermitte -> Hüftmitte)
      ctx.strokeStyle = colTorso;
      ctx.lineWidth = lwBase;
      ctx.beginPath();
      ctx.moveTo(sh.x, sh.y);
      ctx.lineTo(hp.x, hp.y);
      ctx.stroke();

      // Kopf/HWS-Achse (Nase -> Schultermitte)
      if (headVec) {
        ctx.strokeStyle = colHead;
        ctx.lineWidth = lwHead;
        ctx.beginPath();
        ctx.moveTo(nose._cx, nose._cy);
        ctx.lineTo(sh.x, sh.y);
        ctx.stroke();
      }

      // Marker an Schulter-/Hüftmitte
      ctx.fillStyle = colTorso;
      ctx.beginPath(); ctx.arc(sh.x, sh.y, rMid, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(hp.x, hp.y, rMid, 0, Math.PI*2); ctx.fill();

      ctx.restore();
    }

    // ---------- Timer / Slots ----------
    const glideTimes = [];
    let glideActive=false, glideStart=0, currentElapsed=0;
    let poseStableSince=null, poseLostSince=null;

    const distN = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    const fmt = (ms)=> (ms/1000).toFixed(3) + " s";

    function isStandOverhead(lms){
      const ls=lms[11], rs=lms[12], lw=lms[15], rw=lms[16], le=lms[13], re=lms[14];
      if(!ls||!rs||!lw||!rw||!le||!re) return false;
      const shoulderY=(ls.y+rs.y)/2;
      const wristsUp=(lw.y<shoulderY-0.03)&&(rw.y<shoulderY-0.03);
      const elbowsUp=(le.y<shoulderY+0.02)&&(re.y<shoulderY+0.02);
      const wristsClose=Math.abs(lw.x-rw.x)<0.45;
      return wristsUp && elbowsUp && wristsClose;
    }

    function isGlideStreamlineRobust(lms, preset){
      const ls=lms[11], rs=lms[12], lw=lms[15], rw=lms[16], lh=lms[23], rh=lms[24];
      if(!ls||!rs||!lh||!rh) return false;

      const sh={x:(ls.x+rs.x)/2,y:(ls.y+rs.y)/2};
      const hp={x:(lh.x+rh.x)/2,y:(lh.y+rh.y)/2};
      if(distN(sh,hp)<0.10) return false;

      let leftExt=false, rightExt=false;
      if(ls&&lw) leftExt=distN(ls,lw)>(preset==="back45"?0.23:0.26);
      if(rs&&rw) rightExt=distN(rs,rw)>(preset==="back45"?0.23:0.26);

      // Ein Arm reicht (seitlich fällt oft einer weg)
      if(!leftExt && !rightExt) return false;

      if(lw&&rw){
        const maxD=preset==="back45"?0.60:0.45;
        if(distN(lw,rw)>maxD) return false;
      }
      return true;
    }

    function inGlidePose(lms){
      const p=filmingPreset.value;
      if(p==="stand") return isStandOverhead(lms);
      if(p==="side45") return isGlideStreamlineRobust(lms,"side45");
      return isGlideStreamlineRobust(lms,"back45");
    }

    function updateTimer(lms, now){
      if(!toggleTimer.checked || !lms){
        glideActive=false; poseStableSince=null; poseLostSince=null; currentElapsed=0;
        return;
      }
      const p=filmingPreset.value;
      const startHold=(p==="stand")?220:420;
      const stopHold =(p==="stand")?180:360;

      const ok=inGlidePose(lms);

      if(!glideActive){
        currentElapsed=0;
        if(ok && glideTimes.length<4){
          if(poseStableSince===null) poseStableSince=now;
          if(now - poseStableSince >= startHold){
            glideActive=true; glideStart=now; poseLostSince=null;
          }
        } else poseStableSince=null;
        return;
      }

      currentElapsed = now - glideStart;

      if(!ok){
        if(poseLostSince===null) poseLostSince=now;
        if(now - poseLostSince >= stopHold){
          glideActive=false; poseStableSince=null; poseLostSince=null;
          glideTimes.push(now - glideStart);
          if(glideTimes.length>4) glideTimes.length=4;
          currentElapsed=0;
        }
      } else poseLostSince=null;
    }

    function drawOverlaySmall(debugText=""){
      if(!toggleTimer.checked) return;

      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.42)";
      ctx.strokeStyle="rgba(255,255,255,0.55)";
      ctx.lineWidth=1.5;

      const pad=10;
      const w=Math.min(320, CSS_W-2*pad);
      const h=130;
      const x=CSS_W - w - pad;
      const y=pad;
      const r=12;

      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      ctx.fillStyle="white";
      ctx.font="700 28px system-ui";
      ctx.fillText(glideActive ? fmt(currentElapsed) : "0.000 s", x+12, y+36);

      ctx.font="600 12px system-ui";
      ctx.fillText("Brust – Gleitphase | Slots", x+12, y+56);

      ctx.font="13px system-ui";
      for(let i=0;i<4;i++){
        const t=glideTimes[i]!=null?fmt(glideTimes[i]):"—";
        ctx.fillText(`S${i+1}: ${t}`, x+12 + (i%2)*150, y+78 + Math.floor(i/2)*18);
      }

      if(debugText){
        ctx.font="11px system-ui";
        ctx.fillText(debugText, x+12, y+h-10);
      }
      ctx.restore();
    }

    // ---------- MediaPipe Tasks ----------
    let landmarker=null;
    let running=false;
    let rafId=null;

    const POSE_TASK_URL =
      "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task";

    async function createLandmarker(){
      setStatus("Lade Tasks-WASM …");
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
      );

      setStatus("Lade Pose Landmarker …");
      landmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: POSE_TASK_URL },
        runningMode: "VIDEO",
        numPoses: 1,
        outputSegmentationMasks: false,
        minPoseDetectionConfidence: Number(detConf.value),
        minPosePresenceConfidence: Number(presConf.value),
        minTrackingConfidence: Number(trackConf.value),
      });
    }

    function updateLandmarkerThresholds(){
      if(!landmarker) return;
      landmarker.setOptions({
        minPoseDetectionConfidence: Number(detConf.value),
        minPosePresenceConfidence: Number(presConf.value),
        minTrackingConfidence: Number(trackConf.value),
      });
      setStatus("Schwellwerte aktualisiert.");
    }
    detConf.addEventListener("change", updateLandmarkerThresholds);
    presConf.addEventListener("change", updateLandmarkerThresholds);
    trackConf.addEventListener("change", updateLandmarkerThresholds);

    // ---------- Camera ----------
    let isBackCamera=true;
    let stream=null;

    async function startCamera(){
      stopCamera();
      stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{
          facingMode: isBackCamera ? "environment" : "user",
          width:{ideal:1280},
          height:{ideal:720}
        }
      });
      video.srcObject = stream;

      await new Promise((resolve)=>{
        const done=()=>resolve();
        if(video.readyState>=1) return done();
        video.onloadedmetadata = done;
      });
      await video.play();

      await new Promise((resolve)=>{
        const check=()=> (video.videoWidth>0 && video.videoHeight>0) ? resolve() : requestAnimationFrame(check);
        check();
      });
    }

    function stopCamera(){
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      video.srcObject=null;
    }

    // ---------- Loop ----------
    function loop(){
      if(!running || !landmarker) return;

      try{
        ctx.fillStyle = BG;
        ctx.fillRect(0,0,CSS_W,CSS_H);

        if(video.videoWidth===0 || video.videoHeight===0){
          drawOverlaySmall("DEBUG: video not ready");
          rafId = requestAnimationFrame(loop);
          return;
        }

        const ts = performance.now();
        const result = landmarker.detectForVideo(video, ts);
        const hasLandmarks = !!(result?.landmarks?.length && result.landmarks[0]?.length);

        if (hasLandmarks){
          const raw = result.landmarks[0];

          const mirrorX = !isBackCamera;
          const mapped = mapLandmarksToCss(raw, video.videoWidth, video.videoHeight, CSS_W, CSS_H, mirrorX);
          const cssPoints = ema(mapped);

          // HWS-Achse (vor oder nach Skelett – je nach Optik; hier nach Skelett)
          drawSkeletonCssPoints(cssPoints);
          drawHeadTorsoAxis(cssPoints);

          updateTimer(raw, ts);
        } else {
          updateTimer(null, ts);
        }

        drawOverlaySmall(`lm=${hasLandmarks?33:0} ui=${isPortraitUI()?"P":"L"}`);
        rafId = requestAnimationFrame(loop);
      } catch(e){
        console.error(e);
        setStatus("Loop-Fehler: " + (e?.message || String(e)));
        ctx.fillStyle = BG;
        ctx.fillRect(0,0,CSS_W,CSS_H);
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.font = "16px system-ui";
        ctx.fillText("Loop-Fehler: " + (e?.message || String(e)), 20, 40);
      }
    }

    // ---------- Recording ----------
    let recorder=null, recordedChunks=[], lastBlob=null;

    function pickMimeType(){
      const candidates=[
        'video/mp4;codecs="avc1.42E01E"',
        'video/mp4;codecs="avc1.4D401E"',
        "video/mp4",
        'video/webm;codecs="vp8"',
        "video/webm"
      ];
      if(!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
      for(const t of candidates){ try{ if(MediaRecorder.isTypeSupported(t)) return t; } catch(_){} }
      return "";
    }

    function startRecordingCanvas(){
      recordedChunks=[]; lastBlob=null; btnShare.disabled=true;
      const s = canvas.captureStream(15);
      const mt = pickMimeType();
      try{ recorder=new MediaRecorder(s, mt?{mimeType:mt}:undefined); }
      catch(_){ recorder=new MediaRecorder(s); }

      setStatus("Aufnahme läuft… (" + (recorder.mimeType || mt || "default") + ")");
      recorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
      recorder.onstop=()=>{
        const type = recorder.mimeType || mt || "video/webm";
        lastBlob = new Blob(recordedChunks,{type});
        btnShare.disabled = !lastBlob;
        setStatus("Aufnahme fertig (" + (lastBlob.type.includes("mp4") ? "MP4" : "WebM") + ").");
      };
      recorder.start(200);
    }

    function stopRecordingCanvas(){ if(recorder && recorder.state!=="inactive") recorder.stop(); }

    async function shareOrDownload(){
      if(!lastBlob) return;
      const type=lastBlob.type||"";
      const ext=type.includes("mp4")?"mp4":(type.includes("webm")?"webm":"bin");
      const fileName=`bewegungsanalyse_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
      const file=new File([lastBlob],fileName,{type:lastBlob.type});

      if(navigator.canShare && navigator.canShare({files:[file]})){
        await navigator.share({files:[file], title:"Bewegungsanalyse Recorder (anonym)"});
        setStatus("Geteilt/gespeichert ("+ext.toUpperCase()+").");
        return;
      }
      const url=URL.createObjectURL(lastBlob);
      const a=document.createElement("a");
      a.href=url; a.download=fileName;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),2000);
      setStatus("Download gestartet ("+ext.toUpperCase()+").");
    }

    // ---------- Buttons ----------
    btnInit.addEventListener("click", async ()=>{
      try{
        btnInit.disabled=true;
        applyLayoutFromOrientation();
        setStatus("Initialisiere …");

        await createLandmarker();
        await startCamera();

        running=true;
        btnSwitch.disabled=false;
        btnRec.disabled=false;
        btnReset.disabled=false;

        setStatus("bereit.");
        rafId = requestAnimationFrame(loop);
      } catch(e){
        console.error(e);
        setStatus("Fehler: " + (e?.message || String(e)));
        btnInit.disabled=false;
      }
    });

    btnSwitch.addEventListener("click", async ()=>{
      try{
        btnSwitch.disabled=true;

        running=false;
        if(rafId) cancelAnimationFrame(rafId);

        isBackCamera=!isBackCamera;
        await startCamera();

        smoothed=null;
        poseStableSince=null;
        poseLostSince=null;

        running=true;
        rafId = requestAnimationFrame(loop);

        btnSwitch.disabled=false;
        setStatus("Kamera gewechselt.");
      } catch(e){
        console.error(e);
        setStatus("Kamerawechsel-Fehler: " + (e?.message || String(e)));
        running=true;
        rafId = requestAnimationFrame(loop);
        btnSwitch.disabled=false;
      }
    });

    btnRec.addEventListener("click", ()=>{
      btnRec.disabled=true;
      btnStop.disabled=false;
      startRecordingCanvas();
    });

    btnStop.addEventListener("click", ()=>{
      btnStop.disabled=true;
      stopRecordingCanvas();
      btnRec.disabled=false;
    });

    btnShare.addEventListener("click", ()=>shareOrDownload());

    btnReset.addEventListener("click", ()=>{
      glideTimes.length=0;
      glideActive=false; poseStableSince=null; poseLostSince=null; currentElapsed=0;
      setStatus("Slots zurückgesetzt.");
    });

    // Initial layout
    applyLayoutFromOrientation();
  </script>
</body>
</html>
