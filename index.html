<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pose Recorder (Privacy Skeleton)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    video, canvas { max-width: 100%; width: 480px; height: auto; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; background: #fff; }
    button.primary { border-color: #111; }
    .hint { color: #555; font-size: 14px; line-height: 1.4; }
  </style>
</head>
<body>
  <h1>Pose Recorder (nur Skelett-Video)</h1>
  <p class="hint">
    Speichert nur die abstrahierte Skelettdarstellung (Canvas), nicht das Kamerabild.
    Für iPhones per HTTPS hosten.
  </p>

  <div class="row">
    <button id="btnInit" class="primary">Kamera aktivieren</button>
    <button id="btnRec" disabled>Aufnahme starten</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnShare" disabled>Teilen/Speichern</button>
  </div>

  <div class="row">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <p class="hint" id="status">Status: bereit</p>

  <script type="module">
    import vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";
    const { PoseLandmarker, FilesetResolver, DrawingUtils } = vision;

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const btnInit = document.getElementById("btnInit");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const statusEl = document.getElementById("status");

    let poseLandmarker = null;
    let drawingUtils = null;
    let rafId = null;

    // Recorder state
    let recorder = null;
    let recordedChunks = [];
    let lastBlob = null;

    function setStatus(s) { statusEl.textContent = "Status: " + s; }

    // Pick a supported mimeType (iOS differs)
    function pickMimeType() {
      const candidates = [
        "video/webm;codecs=vp9",
        "video/webm;codecs=vp8",
        "video/webm",
        "video/mp4" // sometimes supported, often not with MediaRecorder on iOS
      ];
      for (const t of candidates) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
      }
      return ""; // let browser choose
    }

    async function initPose() {
      setStatus("lade MediaPipe PoseLandmarker…");
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
      );

      // Lite model: schnell und ausreichend für Unterricht
      // (Sie können die .task Datei auch selbst hosten)
      const modelUrl = "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task";

      poseLandmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: modelUrl },
        runningMode: "VIDEO",
        numPoses: 1
      });

      drawingUtils = new DrawingUtils(ctx);
      setStatus("PoseLandmarker bereit.");
    }

    async function initCamera() {
      setStatus("fordere Kamera an…");
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "environment", // im Bad meist besser; ggf. "user"
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      video.srcObject = stream;

      await new Promise((res) => { video.onloadedmetadata = () => res(); });

      // Canvas auf Videogröße setzen
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      setStatus("Kamera aktiv. Pose-Overlay läuft.");
    }

    function drawSkeleton(result) {
      // Hintergrund bewusst neutral (keine Person sichtbar)
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!result?.landmarks?.length) return;

      // Landmarks: Array<NormalizedLandmark> pro Pose
      const landmarks = result.landmarks[0];

      // Zeichnen: Skelett + Punkte
      drawingUtils.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS, { lineWidth: 4 });
      drawingUtils.drawLandmarks(landmarks, { radius: 3 });

      // Optional: Beispiel-Winkel (Knie rechts), sehr simpel berechnet
      // Indizes nach MediaPipe Pose: hip=24, knee=26, ankle=28 (rechte Seite)
      const hip = landmarks[24], knee = landmarks[26], ankle = landmarks[28];
      if (hip && knee && ankle) {
        const ang = angleDeg(hip, knee, ankle);
        ctx.font = "28px system-ui";
        ctx.fillText(`Knie (R): ${Math.round(ang)}°`, 20, 40);
      }
    }

    function angleDeg(a, b, c) {
      // Winkel ABC
      const abx = a.x - b.x, aby = a.y - b.y;
      const cbx = c.x - b.x, cby = c.y - b.y;
      const dot = abx*cbx + aby*cby;
      const mag1 = Math.hypot(abx, aby);
      const mag2 = Math.hypot(cbx, cby);
      const cos = dot / (mag1 * mag2 + 1e-9);
      const clamped = Math.max(-1, Math.min(1, cos));
      return Math.acos(clamped) * (180 / Math.PI);
    }

    function loop() {
      const nowMs = performance.now();
      const res = poseLandmarker.detectForVideo(video, nowMs);
      drawSkeleton(res);
      rafId = requestAnimationFrame(loop);
    }

    function startLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(loop);
    }

    function stopLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function startRecording() {
      recordedChunks = [];
      lastBlob = null;
      btnShare.disabled = true;

      const fps = 15; // für iPhones meist stabil genug
      const stream = canvas.captureStream(fps);

      const mimeType = pickMimeType();
      const options = mimeType ? { mimeType } : undefined;

      recorder = new MediaRecorder(stream, options);
      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        lastBlob = new Blob(recordedChunks, { type: recorder.mimeType || "video/webm" });
        btnShare.disabled = !lastBlob;
        setStatus(`Aufnahme fertig (${Math.round(lastBlob.size/1024)} KB).`);
      };

      recorder.start(200); // alle 200ms Chunks
      setStatus("Aufnahme läuft…");
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") recorder.stop();
    }

    async function shareOrDownload() {
      if (!lastBlob) return;
      const ext = (lastBlob.type.includes("mp4")) ? "mp4" : "webm";
      const file = new File([lastBlob], `pose_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`, { type: lastBlob.type });

      // iOS: Share Sheet ist oft der sauberste Weg
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: "Pose-Aufnahme" });
        setStatus("Geteilt/gespeichert.");
        return;
      }

      // Fallback: Download-Link
      const url = URL.createObjectURL(lastBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = file.name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Download gestartet (Fallback).");
    }

    btnInit.addEventListener("click", async () => {
      try {
        btnInit.disabled = true;
        await initPose();
        await initCamera();
        startLoop();
        btnRec.disabled = false;
        setStatus("bereit für Aufnahme.");
      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + (err?.message || err));
        btnInit.disabled = false;
      }
    });

    btnRec.addEventListener("click", () => {
      btnRec.disabled = true;
      btnStop.disabled = false;
      startRecording();
    });

    btnStop.addEventListener("click", () => {
      btnStop.disabled = true;
      stopRecording();
      btnRec.disabled = false;
    });

    btnShare.addEventListener("click", () => shareOrDownload());
  </script>
</body>
</html>
