<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MOTAXIS - Anonyme Bewegungsanalyse</title>

<style>
:root{
--bg: #bfe7ff;
--ink: #0f172a;
--muted: #475569;
--card: #ffffff;
--border: #e5e7eb;

/* Header/Intro Box (nicht blau) */
--introBg: #f8fafc;
--introBorder: #e2e8f0;
--accent: #111827;
}

body{
font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
margin: 16px;
color: var(--ink);
background: #fff;
}

.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
.hint { color: var(--muted); font-size: 14px; line-height: 1.45; max-width: 1100px; }

/* Header */
.header{
border: 1px solid var(--border);
border-radius: 16px;
padding: 14px 14px 12px 14px;
margin-bottom: 12px;
background: var(--card);
max-width: 1100px;
}
.brand{
display:flex;
flex-direction:column;
gap: 2px;
margin-bottom: 10px;
}
.brand .logo{
font-weight: 900;
letter-spacing: 1.6px;
font-size: 26px;
line-height: 1.05;
text-transform: uppercase;
color: var(--accent);
}
.brand .sub{
font-weight: 700;
letter-spacing: 0.6px;
font-size: 13px;
color: #334155;
text-transform: uppercase;
}

.introBox{
border: 1px solid var(--introBorder);
border-radius: 14px;
padding: 12px 14px;
background: var(--introBg);
}
.introBox p{
margin: 0;
color: #1f2a33;
font-size: 13.75px;
line-height: 1.45;
text-align: left;
text-justify: auto;
}

.stack{
display: grid;
grid-template-columns: 1fr;
gap: 12px;
max-width: 1100px;
}

.block{
border: 1px solid var(--border);
border-radius: 12px;
padding: 10px 12px;
background: var(--card);
}
.blockTitle{
font-weight: 800;
margin: 0 0 10px 0;
font-size: 13px;
color: #0b1220;
letter-spacing: 0.2px;
}

details{
border: 1px solid var(--border);
border-radius: 12px;
padding: 10px 12px;
background: var(--card);
}
summary{
cursor: pointer;
font-weight: 800;
color: #0b1220;
}

label{
display: inline-flex;
align-items: center;
gap: 8px;
padding: 8px 10px;
border: 1px solid var(--border);
border-radius: 10px;
background: var(--card);
font-size: 14px;
}
select{
padding: 9px 12px;
border-radius: 10px;
border: 1px solid #cbd5e1;
background: var(--card);
font: inherit;
color: #0b1220;
}

button{
padding: 10px 14px;
border-radius: 10px;
border: 1px solid #cbd5e1;
background: var(--card);
font: inherit;
color: #0b1220;
}
button.primary{
border-color: #0b1220;
font-weight: 700;
}
button:disabled{ opacity: 0.5; }

.btnRow{ display:flex; gap:10px; flex-wrap: wrap; }
.btnRow button{ flex: 1 1 auto; }
.btnRow .wide{ flex: 1 1 100%; }

video, canvas{
max-width: 100%;
border: 1px solid var(--border);
border-radius: 10px;
}
video{ width: 360px; height: auto; background:#000; }
canvas{ width: 360px; height: auto; background: var(--bg); }

.videoHidden{
width: 1px !important;
height: 1px !important;
opacity: 0 !important;
position: absolute !important;
left: -9999px !important;
top: -9999px !important;
pointer-events: none !important;
}

.rangeWrap{
display:flex;
align-items:center;
gap:10px;
padding: 8px 10px;
border:1px solid var(--border);
border-radius: 10px;
margin-top: 10px;
flex-wrap: wrap;
background: var(--card);
}
.rangeWrap span{ min-width: 170px; font-size: 13px; color:#475569; }
.small{ font-size: 13px; color:#475569; min-width: 64px; text-align:right; }

.tipsBox{
margin-top: 10px;
border: 2px solid #16a34a;
border-radius: 12px;
padding: 10px 12px;
background: #f0fdf4;
display: none;
max-width: 1100px;
}
.tipsBox h3{ margin: 0 0 6px 0; font-size: 14px; }
.tipsBox ul{ margin: 6px 0 0 18px; padding: 0; }
.pill{
display: inline-block;
padding: 2px 8px;
border-radius: 999px;
border: 1px solid #bbf7d0;
font-size: 12px;
color: #14532d;
background: #ecfdf5;
margin-left: 6px;
}

/* Feedback form */
.fbWrap{ display:flex; flex-direction:column; gap:10px; margin-top:10px; max-width: 820px; }
.fbRow{ display:flex; flex-direction:column; gap:6px; }
.fbRow input, .fbRow textarea{
width: 100%;
padding: 10px 12px;
border-radius: 10px;
border: 1px solid #cbd5e1;
font: inherit;
background: #fff;
box-sizing: border-box;
}
.fbRow textarea{ min-height: 120px; resize: vertical; }
.fbFine{ font-size: 12.5px; color:#64748b; line-height:1.35; }
.fbStatus{ font-size: 13px; color:#334155; margin-top: 6px; display:none; }
.fbStatus.ok{ color: #0b6b0b; }
.fbStatus.err{ color: #a10000; }

#status{ margin-top: 12px; max-width: 1100px; }
</style>
</head>

<body>
<div class="header">
  <div class="brand">
    <div class="logo">MOTAXIS</div>
    <div class="sub">Anonyme Bewegungsanalyse</div>
  </div>
  <div class="introBox">
    <p>
      Beta-Version zur anonymen Aufnahme und Analyse von Skelettachsen und Bewegungen.
      Bislang optimiert für Brustschwimmen. Auswertungen sind experimentell und können je nach Aufnahmebedingungen variieren.
    </p>
  </div>
</div>

<video id="video" class="videoHidden" playsinline autoplay muted></video>

<div class="stack">

  <div class="block">
    <div class="blockTitle">Kamera</div>
    <div class="btnRow">
      <button id="btnInit" class="primary wide">Kamera aktivieren</button>
      <button id="btnSwitch" disabled class="wide">Kamera wechseln (Rück)</button>
    </div>
  </div>

  <details id="displayBox" open>
    <summary>Anzeige (allgemein)</summary>

    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
      <label><input type="checkbox" id="toggleSkeleton" checked /> Skelett</label>
      <label><input type="checkbox" id="toggleSilhouette" checked /> Segmentierung</label>

      <label style="border:none; padding:0; background:transparent;">
        <span style="font-weight:800; color:#0b1220;">Kameraperspektive</span>
      </label>

      <select id="filmingPreset" title="Kameraperspektive">
        <option value="side45" selected>Schräg seitlich (leicht von oben)</option>
        <option value="back45">Schräg von hinten (leicht von oben)</option>
        <option value="stand">Frontal (Stand)</option>
      </select>
    </div>

    <details id="advancedBox" style="margin-top:10px;">
      <summary>Erweiterte Einstellungen</summary>

      <div class="rangeWrap">
        <span>Input-Video anzeigen</span>
        <label style="border:none; padding:0; border-radius:0;">
          <input type="checkbox" id="showInputVideo" />
          <span class="small">anzeigen</span>
        </label>
        <span class="hint" style="max-width:none;">(Optional – Output bleibt anonym.)</span>
      </div>

      <div class="rangeWrap">
        <span>Segmentierung – Deckkraft</span>
        <input id="silOpacity" type="range" min="0" max="1" step="0.05" value="0.40">
        <span id="silOpacityVal" class="small">0.40</span>
      </div>

      <div class="rangeWrap">
        <span>Segmentierung – Schwelle</span>
        <input id="silThresh" type="range" min="0" max="100" step="1" value="70">
        <span id="silThreshVal" class="small">70</span>
      </div>

      <div class="rangeWrap">
        <span>Skelett – Linienstärke</span>
        <input id="skelLine" type="range" min="1" max="10" step="1" value="3">
        <span id="skelLineVal" class="small">3</span>
      </div>

      <div class="rangeWrap">
        <span>Skelett – Punkt-Radius</span>
        <input id="skelDot" type="range" min="1" max="10" step="1" value="4">
        <span id="skelDotVal" class="small">4</span>
      </div>

      <div class="rangeWrap">
        <span>Detection (min)</span>
        <input id="detConf" type="range" min="0.3" max="0.95" step="0.01" value="0.50">
        <span id="detVal" class="small">0.50</span>
      </div>

      <div class="rangeWrap">
        <span>Presence (min)</span>
        <input id="presConf" type="range" min="0.3" max="0.95" step="0.01" value="0.50">
        <span id="presVal" class="small">0.50</span>
      </div>

      <div class="rangeWrap">
        <span>Tracking (min)</span>
        <input id="trackConf" type="range" min="0.3" max="0.95" step="0.01" value="0.55">
        <span id="trackVal" class="small">0.55</span>
      </div>

      <div class="rangeWrap">
        <span>Glättung (EMA)</span>
        <input id="smooth" type="range" min="0" max="0.9" step="0.05" value="0.55">
        <span id="smoothVal" class="small">0.55</span>
      </div>

      <div class="rangeWrap">
        <span>HWS – Grün-Toleranz (°)</span>
        <input id="neckTol" type="range" min="6" max="35" step="1" value="14">
        <span id="neckTolVal" class="small">14</span>
      </div>

      <div class="rangeWrap">
        <span>HWS – Neutral-Offset (°)</span>
        <input id="neckNeutral" type="range" min="-10" max="25" step="1" value="12">
        <span id="neckNeutralVal" class="small">12</span>
      </div>

      <div class="rangeWrap">
        <span>HWS – Rot-Schwelle extra (°)</span>
        <input id="neckRedExtra" type="range" min="0" max="20" step="1" value="6">
        <span id="neckRedExtraVal" class="small">6</span>
      </div>

      <div class="rangeWrap">
        <span>HWS – Glättung (EMA)</span>
        <input id="neckEma" type="range" min="0.60" max="0.90" step="0.01" value="0.82">
        <span id="neckEmaVal" class="small">0.82</span>
      </div>

      <div class="rangeWrap">
        <span>HWS – Hold (ms)</span>
        <input id="neckHold" type="range" min="80" max="350" step="10" value="180">
        <span id="neckHoldVal" class="small">180</span>
      </div>

    </details>
  </details>

  <details id="breastTools">
    <summary>Brustschwimmen-Tools (spezifisch)</summary>

    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
      <label><input type="checkbox" id="toggleNeck" checked /> HWS-Achse</label>
      <label><input type="checkbox" id="toggleLegCheck" checked /> Knie/Beine-Check</label>
      <label><input type="checkbox" id="toggleHandAxis" checked /> Hand-Achse (Armzug)</label>
      <label><input type="checkbox" id="toggleTimer" checked /> Timer – Gleitphase</label>
      <label><input type="checkbox" id="toggleHintBox" checked /> Techniktipps nach Stop</label>
    </div>

    <details style="margin-top:10px;">
      <summary>Technik-Checkliste (Brust)</summary>

      <p class="hint">
        Hinweise sind experimentell. Am besten beurteilbar in <b>45° seitlich</b> oder <b>45° hinten</b>.
      </p>

      <details>
        <summary>Armzug zu breit</summary>
        <p class="hint">
          <b>Indikator:</b> Hände öffnen sich in der Zugphase deutlich über Schulterbreite.<br>
          <b>Merksatz:</b> Arme drücken vor allem nach hinten – weniger nach außen.
        </p>
      </details>

      <details>
        <summary>Hände ziehen zu tief</summary>
        <p class="hint">
          <b>Indikator:</b> Hände wandern in der Zugphase deutlich unter Schulter-/Brusthöhe in Richtung Hüfte/Füße.<br>
          <b>Merksatz:</b> Druck nach hinten – nicht nach unten.
        </p>
      </details>

      <details>
        <summary>Streck-/Stromlinienphase fehlt</summary>
        <p class="hint">
          <b>Indikator:</b> Nach dem Armzug folgt selten eine klare, gestreckte Körperhaltung (Arme geschlossen/über Kopf, Beine gestreckt).<br>
          <b>Merksatz:</b> Wenn nichts arbeitet, muss alles schlank sein.
        </p>
      </details>

      <details>
        <summary>Beinschlag übernimmt zu spät</summary>
        <p class="hint">
          <b>Indikator:</b> Nach dem Armschließen entsteht häufig eine Pause, bevor der Beinschlag einsetzt.<br>
          <b>Merksatz:</b> Kick startet, wenn die Hände nach vorn gehen.
        </p>
      </details>

      <details>
        <summary>Knie ziehen zu breit an (Rückholphase)</summary>
        <p class="hint">
          <b>Indikator:</b> Knieöffnung in der Rückholphase deutlich größer als Schulterbreite.<br>
          <b>Merksatz:</b> Rückholen schmal – Kick kräftig.
        </p>
      </details>

      <details>
        <summary>Beinschere</summary>
        <p class="hint">
          <b>Indikator:</b> Deutlich asymmetrische Beinbewegung links/rechts über mehrere Frames.<br>
          <b>Hinweis:</b> Nur bei Rückenansicht sinnvoll bewertbar.
        </p>
      </details>

      <details>
        <summary>Gleitphase</summary>
        <p class="hint">
          <b>Indikator:</b> Nach dem Strecken zu kurz oder (seltener) sehr lang ohne sinnvollen Übergang zur nächsten Phase.<br>
          <b>Merksatz:</b> Kurz stabil gleiten – dann sauber einleiten.
        </p>
      </details>
    </details>
  </details>

  <div class="block">
    <div class="blockTitle">Aufnahme</div>
    <div class="btnRow">
      <button id="btnRec" disabled class="wide">Aufnahme starten</button>
      <button id="btnStop" disabled>Stop</button>
      <button id="btnShare" disabled>Teilen/Speichern</button>
      <button id="btnReset" disabled class="wide">Slots zurücksetzen</button>
    </div>
  </div>

  <div>
    <canvas id="canvas"></canvas>
  </div>

  <div id="tipsBox" class="tipsBox">
    <h3>Techniktipps Brustschwimmen <span id="hintMeta" class="pill"></span></h3>
    <div class="hint" id="hintText"></div>
    <ul id="hintList"></ul>
  </div>

  <details id="feedbackBox">
    <summary>Feedback / Fehler melden</summary>
    <div class="hint" style="margin-top:8px; max-width: 820px;">
      Wenn dir ein Fehler auffällt oder du eine sinnvolle Verbesserungsidee hast, schick sie hier ab.
      (Das Formular sendet über Formspree an das MOTAXIS-Postfach.)
    </div>

    <form
      id="feedbackForm"
      class="fbWrap"
      action="https://formspree.io/f/mzdbqzog"
      method="POST"
    >
      <div class="fbRow">
        <div class="fbFine">Deine E-Mail (optional, falls Rückfragen)</div>
        <input type="email" name="email" placeholder="name@beispiel.de" autocomplete="email" />
      </div>

      <div class="fbRow">
        <div class="fbFine">Nachricht</div>
        <textarea name="message" placeholder="Was ist passiert? (Gerät/Browser, Aufnahmewinkel, Schritte zum Reproduzieren, ggf. Screenshot-Beschreibung)"></textarea>
      </div>

      <input type="hidden" name="app" value="MOTAXIS" />
      <input type="hidden" name="version" value="2026-02-03" />
      <input type="hidden" id="fbMeta" name="meta" value="" />

      <div class="btnRow" style="max-width: 420px;">
        <button id="btnFbSend" type="submit" class="primary">Senden</button>
      </div>

      <div id="fbStatus" class="fbStatus"></div>
    </form>
  </details>

</div>

<p class="hint mono" id="status">Status: bereit</p>

<script type="module">
import { FilesetResolver, PoseLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

/* =========================
MINIMALE PERFORMANCE-ANPASSUNGEN
1) Segmentierungs-Maske NICHT in jedem Frame neu pixeln:
   -> nur alle MASK_INTERVAL_MS neu berechnen, dazwischen cached Maske zeichnen.
2) ImageData für Maske wiederverwenden (kein createImageData pro Frame).
Alle restlichen Logiken bleiben gleich.
========================= */
const MASK_INTERVAL_MS = 100; // ~10 fps Masken-Update (Preview bleibt schneller)

// DOM
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const btnInit = document.getElementById("btnInit");
const btnSwitch = document.getElementById("btnSwitch");
const btnRec = document.getElementById("btnRec");
const btnStop = document.getElementById("btnStop");
const btnShare = document.getElementById("btnShare");
const btnReset = document.getElementById("btnReset");

const toggleSkeleton = document.getElementById("toggleSkeleton");
const toggleSilhouette = document.getElementById("toggleSilhouette");

const toggleNeck = document.getElementById("toggleNeck");
const toggleLegCheck = document.getElementById("toggleLegCheck");
const toggleHandAxis = document.getElementById("toggleHandAxis");
const toggleTimer = document.getElementById("toggleTimer");
const toggleHintBox = document.getElementById("toggleHintBox");
const filmingPreset = document.getElementById("filmingPreset");

const showInputVideo = document.getElementById("showInputVideo");

const silOpacity = document.getElementById("silOpacity");
const silThresh = document.getElementById("silThresh");
const skelLine  = document.getElementById("skelLine");
const skelDot   = document.getElementById("skelDot");
const detConf = document.getElementById("detConf");
const presConf = document.getElementById("presConf");
const trackConf = document.getElementById("trackConf");
const smooth = document.getElementById("smooth");

const neckTol = document.getElementById("neckTol");
const neckNeutral = document.getElementById("neckNeutral");
const neckRedExtra = document.getElementById("neckRedExtra");
const neckEma = document.getElementById("neckEma");
const neckHold = document.getElementById("neckHold");

const silOpacityVal = document.getElementById("silOpacityVal");
const silThreshVal  = document.getElementById("silThreshVal");
const skelLineVal   = document.getElementById("skelLineVal");
const skelDotVal    = document.getElementById("skelDotVal");
const detVal = document.getElementById("detVal");
const presVal = document.getElementById("presVal");
const trackVal = document.getElementById("trackVal");
const smoothVal = document.getElementById("smoothVal");

const neckTolVal = document.getElementById("neckTolVal");
const neckNeutralVal = document.getElementById("neckNeutralVal");
const neckRedExtraVal = document.getElementById("neckRedExtraVal");
const neckEmaVal = document.getElementById("neckEmaVal");
const neckHoldVal = document.getElementById("neckHoldVal");

const tipsBox = document.getElementById("tipsBox");
const hintList = document.getElementById("hintList");
const hintText = document.getElementById("hintText");
const hintMeta = document.getElementById("hintMeta");

const statusEl = document.getElementById("status");
const setStatus = (s) => statusEl.textContent = "Status: " + s;

// Feedback DOM
const feedbackForm = document.getElementById("feedbackForm");
const fbMeta = document.getElementById("fbMeta");
const fbStatus = document.getElementById("fbStatus");

function bindSlider(el, out, fmt=(v)=>Number(v).toFixed(2)) {
  const update = () => out.textContent = fmt(el.value);
  el.addEventListener("input", update);
  update();
}
bindSlider(silOpacity, silOpacityVal, v => Number(v).toFixed(2));
bindSlider(silThresh,  silThreshVal,  v => String(Math.round(Number(v))));
bindSlider(skelLine,   skelLineVal,   v => String(Math.round(Number(v))));
bindSlider(skelDot,    skelDotVal,    v => String(Math.round(Number(v))));
bindSlider(detConf, detVal);
bindSlider(presConf, presVal);
bindSlider(trackConf, trackVal);
bindSlider(smooth, smoothVal, v => Number(v).toFixed(2));

bindSlider(neckTol, neckTolVal, v => String(Math.round(Number(v))));
bindSlider(neckNeutral, neckNeutralVal, v => String(Math.round(Number(v))));
bindSlider(neckRedExtra, neckRedExtraVal, v => String(Math.round(Number(v))));
bindSlider(neckEma, neckEmaVal, v => Number(v).toFixed(2));
bindSlider(neckHold, neckHoldVal, v => String(Math.round(Number(v))));

function setInputVideoVisible(visible) {
  if (visible) video.classList.remove("videoHidden");
  else video.classList.add("videoHidden");
}
setInputVideoVisible(false);
showInputVideo?.addEventListener("change", () => setInputVideoVisible(showInputVideo.checked));

// Orientation + HiDPI
function isPortraitUI() {
  const so = screen.orientation && screen.orientation.type;
  if (typeof so === "string") return so.includes("portrait");
  if (window.matchMedia) return window.matchMedia("(orientation: portrait)").matches;
  return window.innerHeight >= window.innerWidth;
}

let CSS_W = 360, CSS_H = 640;
function setupHiDPICanvas(cssW, cssH) {
  CSS_W = cssW; CSS_H = cssH;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.imageSmoothingEnabled = false;
}
function applyLayoutFromOrientation() {
  if (isPortraitUI()) setupHiDPICanvas(360, 640);
  else setupHiDPICanvas(720, 405);
  setStatus("Ausrichtung: " + (isPortraitUI() ? "Hochformat" : "Querformat"));
}
window.addEventListener("resize", applyLayoutFromOrientation);
window.addEventListener("orientationchange", applyLayoutFromOrientation);
applyLayoutFromOrientation();

const BG = "#bfe7ff";

// Pose connections
const POSE_CONNECTIONS = [
  [0,1],[1,2],[2,3],[3,7],
  [0,4],[4,5],[5,6],[6,8],
  [9,10],
  [11,12],
  [11,13],[13,15],[15,17],[15,19],[15,21],
  [12,14],[14,16],[16,18],[16,20],[16,22],
  [11,23],[12,24],[23,24],
  [23,25],[25,27],[27,29],[29,31],
  [24,26],[26,28],[28,30],[30,32]
];

// Helpers
const dist = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
const distPx = (a,b)=>Math.hypot(a._cx-b._cx, a._cy-b._cy);
const distXPx = (a,b)=>Math.abs(a._cx - b._cx);

function angleBetween(u, v) {
  const dot = u.x*v.x + u.y*v.y;
  const nu = Math.hypot(u.x,u.y), nv = Math.hypot(v.x,v.y);
  if (!nu || !nv) return 0;
  const c = Math.max(-1, Math.min(1, dot/(nu*nv)));
  return Math.acos(c) * 180/Math.PI;
}
function signedAngleDeg(a, b) {
  const cross = a.x*b.y - a.y*b.x;
  const dot   = a.x*b.x + a.y*b.y;
  return Math.atan2(cross, dot) * 180/Math.PI;
}
function normVec(v){
  const n = Math.hypot(v.x, v.y) || 1;
  return { x: v.x/n, y: v.y/n };
}

function kneeAngle(hip, knee, ankle) {
  if (!hip || !knee || !ankle) return null;
  const u = { x: hip.x - knee.x, y: hip.y - knee.y };
  const v = { x: ankle.x - knee.x, y: ankle.y - knee.y };
  return angleBetween(u, v);
}
function elbowAngle(shoulder, elbow, wrist) {
  if (!shoulder || !elbow || !wrist) return null;
  const u = { x: shoulder.x - elbow.x, y: shoulder.y - elbow.y };
  const v = { x: wrist.x - elbow.x, y: wrist.y - elbow.y };
  return angleBetween(u, v);
}

function mapLandmarksContain(rawLandmarks, vw, vh, cw, ch) {
  const scale = Math.min(cw / vw, ch / vh);
  const dispW = vw * scale;
  const dispH = vh * scale;
  const offX = (cw - dispW) / 2;
  const offY = (ch - dispH) / 2;

  return rawLandmarks.map(p => {
    const px = p.x * vw;
    const py = p.y * vh;
    return { ...p, _cx: offX + px * scale, _cy: offY + py * scale };
  });
}

// EMA smoothing in CSS space (for points)
let smoothedCss = null;
function emaCss(cssPoints) {
  const a = Number(smooth.value);
  if (!cssPoints) return null;
  if (!smoothedCss || smoothedCss.length !== cssPoints.length) {
    smoothedCss = cssPoints.map(p => ({ ...p }));
    return smoothedCss;
  }
  for (let i = 0; i < cssPoints.length; i++) {
    const p = cssPoints[i], s = smoothedCss[i];
    s._cx = a * s._cx + (1 - a) * p._cx;
    s._cy = a * s._cy + (1 - a) * p._cy;
    if (typeof p.visibility === "number") s.visibility = p.visibility;
    if (typeof p.presence === "number") s.presence = p.presence;
  }
  return smoothedCss;
}

// Skeleton
function drawSkeletonCssPoints(cssPoints) {
  if (!toggleSkeleton.checked || !cssPoints) return;
  const lw = Math.round(Number(skelLine.value));
  const r  = Math.round(Number(skelDot.value));

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.strokeStyle = "#000";
  ctx.fillStyle = "#000";
  ctx.lineWidth = lw;

  for (const [a,b] of POSE_CONNECTIONS) {
    const pa = cssPoints[a], pb = cssPoints[b];
    if (!pa || !pb) continue;
    if (typeof pa.visibility === "number" && pa.visibility < 0.15) continue;
    if (typeof pb.visibility === "number" && pb.visibility < 0.15) continue;
    ctx.beginPath();
    ctx.moveTo(pa._cx, pa._cy);
    ctx.lineTo(pb._cx, pb._cy);
    ctx.stroke();
  }

  for (const p of cssPoints) {
    if (!p) continue;
    if (typeof p.visibility === "number" && p.visibility < 0.15) continue;
    ctx.beginPath();
    ctx.arc(p._cx, p._cy, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

// Segmentation
const maskSrcCanvas = document.createElement("canvas");
const maskSrcCtx = maskSrcCanvas.getContext("2d", { willReadFrequently: false });

// ✅ PERF: cached ImageData + throttled rebuild
let maskImg = null;
let lastMaskBuildTs = 0;
let lastMaskMax = 0;
let hasCachedMask = false;

function drawMaskContainFromSource(srcCanvas, vw, vh) {
  const cw = CSS_W, ch = CSS_H;
  const scale = Math.min(cw / vw, ch / vh);
  const dispW = vw * scale;
  const dispH = vh * scale;
  const offX = (cw - dispW) / 2;
  const offY = (ch - dispH) / 2;
  ctx.drawImage(srcCanvas, offX, offY, dispW, dispH);
}

function renderMaskToCanvas(segMask) {
  if (!segMask) return { max: 0 };
  const mw = segMask.width ?? 0;
  const mh = segMask.height ?? 0;
  if (!mw || !mh) return { max: 0 };

  if (maskSrcCanvas.width !== mw || maskSrcCanvas.height !== mh) {
    maskSrcCanvas.width = mw;
    maskSrcCanvas.height = mh;
    maskImg = null; // force recreate
    hasCachedMask = false;
  }

  const threshold = Number(silThresh.value) / 100;
  const alpha = Number(silOpacity.value);

  let dataF = null, dataU = null;
  try { if (typeof segMask.getAsFloat32Array === "function") dataF = segMask.getAsFloat32Array(); } catch(_) {}
  if (!dataF) { try { if (typeof segMask.getAsUint8Array === "function") dataU = segMask.getAsUint8Array(); } catch(_) {} }

  // ✅ PERF: reuse ImageData buffer (kein createImageData pro Frame)
  if (!maskImg || maskImg.width !== mw || maskImg.height !== mh) {
    maskImg = maskSrcCtx.createImageData(mw, mh);
  }
  const d = maskImg.data;

  let maxv = 0;
  const N = mw * mh;

  if (dataF && dataF.length >= N) {
    for (let i = 0; i < N; i++) {
      const v = dataF[i];
      if (v > maxv) maxv = v;
      const a = (v >= threshold) ? Math.round(255 * alpha) : 0;
      const o = i*4;
      d[o] = 255; d[o+1] = 215; d[o+2] = 0; d[o+3] = a;
    }
  } else if (dataU && dataU.length >= N) {
    for (let i = 0; i < N; i++) {
      const v = dataU[i] / 255;
      if (v > maxv) maxv = v;
      const a = (v >= threshold) ? Math.round(255 * alpha) : 0;
      const o = i*4;
      d[o] = 255; d[o+1] = 215; d[o+2] = 0; d[o+3] = a;
    }
  } else {
    return { max: 0 };
  }

  maskSrcCtx.putImageData(maskImg, 0, 0);
  hasCachedMask = true;
  return { max: maxv };
}

// ✅ PERF: throttled drawSilhouette – rebuild only every MASK_INTERVAL_MS, otherwise reuse cached mask canvas
function drawSilhouette(segMask, nowTs) {
  if (!toggleSilhouette.checked || !segMask) return { max: 0 };
  const vw = video.videoWidth || 0;
  const vh = video.videoHeight || 0;
  if (!vw || !vh) return { max: 0 };

  const shouldRebuild = (nowTs - lastMaskBuildTs) >= MASK_INTERVAL_MS;

  let info = { max: lastMaskMax || 0 };
  if (shouldRebuild) {
    info = renderMaskToCanvas(segMask);
    lastMaskBuildTs = nowTs;
    lastMaskMax = info.max ?? 0;
  }

  if (hasCachedMask) drawMaskContainFromSource(maskSrcCanvas, vw, vh);
  return info;
}

// Head center (used for neck rendering)
function headCenterNorm(raw) {
  const le = raw[7], re = raw[8];
  const lEye = raw[2], rEye = raw[5];
  if (le && re) return { x:(le.x+re.x)/2, y:(le.y+re.y)/2 };
  if (lEye && rEye) return { x:(lEye.x+rEye.x)/2, y:(lEye.y+rEye.y)/2 };
  return null;
}
function headCenterCss(cssPoints) {
  const le = cssPoints[7], re = cssPoints[8];
  const lEye = cssPoints[2], rEye = cssPoints[5];
  if (le && re) return { _cx:(le._cx+re._cx)/2, _cy:(le._cy+re._cy)/2 };
  if (lEye && rEye) return { _cx:(lEye._cx+rEye._cx)/2, _cy:(lEye._cy+rEye._cy)/2 };
  return null;
}

// "Profile likely" heuristic
function isProfileLikely(raw){
  const ls = raw[11], rs = raw[12];
  if(!ls || !rs) return false;
  return Math.abs(ls.x - rs.x) < 0.055;
}
function estimateFacingSign(raw, head, shoulder) {
  const nose = raw[0];
  if (nose && head) {
    const dx = nose.x - head.x;
    if (Math.abs(dx) > 0.003) return dx > 0 ? 1 : -1;
  }
  if (head && shoulder) {
    const dx = head.x - shoulder.x;
    if (Math.abs(dx) > 0.003) return dx > 0 ? 1 : -1;
  }
  return 1;
}

// --- HWS state
let neckAngleEma = null;
let neckState = "unknown";
let neckSince = 0;
let neckNeutralAuto = null;
let neckCalibSamples = [];

function resetNeckState(){
  neckAngleEma = null;
  neckState = "unknown";
  neckSince = 0;
  neckNeutralAuto = null;
  neckCalibSamples = [];
}

function drawNeckAxis(rawNorm, cssPoints, nowTs) {
  if (!toggleNeck.checked || !rawNorm || !cssPoints) {
    return { neckDeg: null, state: "unknown", neutral: null, d: null, profile:false, facing:1 };
  }

  const ls = rawNorm[11], rs = rawNorm[12];
  const lh = rawNorm[23], rh = rawNorm[24];
  if (!ls || !rs || !lh || !rh) {
    return { neckDeg: null, state: "unknown", neutral: null, d: null, profile:false, facing:1 };
  }

  const shoulder = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };
  const head     = headCenterNorm(rawNorm);
  if (!head) {
    return { neckDeg: null, state: "unknown", neutral: null, d: null, profile:false, facing:1 };
  }

  const profile = isProfileLikely(rawNorm);
  const facing  = estimateFacingSign(rawNorm, head, shoulder);

  let neutral = null;
  let d = null;

  if (profile) {
    const neckV = normVec({ x: head.x - shoulder.x, y: head.y - shoulder.y });
    const up = { x: 0, y: -1 };
    let ang = signedAngleDeg(up, neckV);
    if (facing < 0) ang = -ang;

    const alpha = Number(neckEma.value);
    if (neckAngleEma == null) neckAngleEma = ang;
    else neckAngleEma = alpha*neckAngleEma + (1-alpha)*ang;

    const neutralManual = Number(neckNeutral.value);
    neutral = (neckNeutralAuto != null) ? neckNeutralAuto : neutralManual;

    if (filmingPreset.value === "stand") {
      const d0 = neckAngleEma - neutralManual;
      if (Math.abs(d0) < 22 && neckCalibSamples.length < 45) {
        neckCalibSamples.push(neckAngleEma);
        if (neckCalibSamples.length === 45) {
          const sorted = neckCalibSamples.slice().sort((a,b)=>a-b);
          neckNeutralAuto = sorted[Math.floor(sorted.length/2)];
          neutral = neckNeutralAuto;
        }
      }
      if (neckNeutralAuto != null) neutral = neckNeutralAuto;
    }

    const greenTol = Number(neckTol.value);
    const redExtra = Number(neckRedExtra.value);
    const flexThr = greenTol + redExtra;
    const extThr  = greenTol + redExtra;

    d = neckAngleEma - neutral;

    let want = "amber";
    if (Math.abs(d) <= greenTol) want = "green";
    else if (d >=  flexThr) want = "redFlex";
    else if (d <= -extThr)  want = "redExt";

    const HOLD_MS = Number(neckHold.value);
    if (want !== neckState) {
      if (!neckSince) neckSince = nowTs;
      if (nowTs - neckSince >= HOLD_MS) {
        neckState = want;
        neckSince = 0;
      }
    } else {
      neckSince = 0;
    }

  } else {
    neckState = "neutral";
    neckSince = 0;
  }

  // Draw axis ALWAYS
  const cssLs = cssPoints[11], cssRs = cssPoints[12];
  const cssShoulder = (cssLs && cssRs) ? { _cx:(cssLs._cx+cssRs._cx)/2, _cy:(cssLs._cy+cssRs._cy)/2 } : null;
  const cssHead = headCenterCss(cssPoints);

  if (cssShoulder && cssHead) {
    let stroke = "rgba(120,120,120,0.85)";
    if (profile) {
      stroke = "rgba(255,140,0,0.95)";
      if (neckState === "green") stroke = "rgba(0,180,0,0.95)";
      if (neckState === "redFlex" || neckState === "redExt") stroke = "rgba(220,0,0,0.95)";
    }
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineWidth = 6;
    ctx.strokeStyle = stroke;
    ctx.beginPath();
    ctx.moveTo(cssShoulder._cx, cssShoulder._cy);
    ctx.lineTo(cssHead._cx, cssHead._cy);
    ctx.stroke();
    ctx.restore();
  }

  return { neckDeg: (profile ? neckAngleEma : null), state: neckState, neutral, d, profile, facing };
}

// Knee/leg checks
function colorForRatio(r) {
  if (r <= 1.35) return "rgba(0,170,0,0.95)";
  if (r <= 1.55) return "rgba(255,140,0,0.95)";
  return "rgba(220,0,0,0.95)";
}

function drawLegChecks(raw, cssPoints) {
  if (!toggleLegCheck.checked || !raw || !cssPoints) return { kneeRatio: null, kneeDiff: null, kneeAngles: [null,null], valid: false };

  const kL = cssPoints[25], kR = cssPoints[26];
  const sL = cssPoints[11], sR = cssPoints[12];

  const okVis = (p)=> (p && (typeof p.visibility !== "number" || p.visibility >= 0.20));
  const valid = !!(kL && kR && sL && sR && okVis(kL) && okVis(kR) && okVis(sL) && okVis(sR));

  if (!valid) return { kneeRatio: null, kneeDiff: null, kneeAngles: [null,null], valid: false };

  const shoulderW = distPx(sL, sR);
  const kneeW = distPx(kL, kR);
  const kneeRatio = (shoulderW > 1) ? (kneeW / shoulderW) : null;

  const lh = raw[23], rh = raw[24], lk = raw[25], rk = raw[26], la = raw[27], ra = raw[28];
  const aL = kneeAngle(lh, lk, la);
  const aR = kneeAngle(rh, rk, ra);
  const diff = (aL != null && aR != null) ? Math.abs(aL - aR) : null;

  if (kneeRatio != null) {
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineWidth = 3;
    ctx.setLineDash([7, 6]);
    ctx.strokeStyle = colorForRatio(kneeRatio);
    ctx.beginPath();
    ctx.moveTo(kL._cx, kL._cy);
    ctx.lineTo(kR._cx, kR._cy);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  return { kneeRatio, kneeDiff: diff, kneeAngles: [aL, aR], valid: true };
}

// Hand axis
function colorForHandRatio(r) {
  if (r <= 2.10) return "rgba(0,170,0,0.95)";
  if (r <= 2.50) return "rgba(255,140,0,0.95)";
  return "rgba(220,0,0,0.95)";
}

/* =========================
TIMER
========================= */
let glideActive = false, glideStart = 0, currentElapsed = 0;
let scoreEma = 0, scoreStableSince = null;
let stopScoreSince = null;
let stopMoveSince  = null;
let ignoreStopUntil = 0;

let lastTorso = null;
const glideTimes = [];
const fmt = (ms)=> (ms/1000).toFixed(3) + " s";

// Robust: "Arm über Kopf / Streamline" (ein Arm reicht)
function armOverHeadRobust(raw) {
  const ls = raw[11], rs = raw[12];
  const le = raw[13], re = raw[14];
  const lw = raw[15], rw = raw[16];
  const head = headCenterNorm(raw);
  if (!ls || !rs) return 0;

  const shoulderY = (ls.y + rs.y) / 2;
  const headY = (head?.y ?? (shoulderY - 0.10));

  // Visibility-gated (Occlusion-resistent)
  const ok = (p, thr=0.25) => (p && (typeof p.visibility !== "number" || p.visibility >= thr));

  const lwOK = ok(lw), rwOK = ok(rw);
  const leOK = ok(le), reOK = ok(re);

  // Perspektiv-spezifisch: side45 braucht oft tolerantere Y-Schwellen,
  // weil Hand/Arm durch Winkel + Wasserreflexe "tiefer" detektiert werden kann.
  const p = filmingPreset.value;
  const wristUpMargin = (p === "side45") ? 0.040 : 0.020; // größer = toleranter
  const elbowUpMargin = (p === "side45") ? 0.020 : 0.040; // kleiner = toleranter

  // "Arm vorn/oben" Kriterien:
  // - Ideal: Wrist oberhalb HeadY (+Margin)
  // - Fallback: Wrist deutlich über SchulterY (bei verdecktem Kopf)
  // - Fallback: Elbow deutlich über SchulterY (wenn Wrist fehlt)
  const leftWristUp  = lwOK ? (lw.y < headY + wristUpMargin || lw.y < shoulderY - 0.010) : false;
  const rightWristUp = rwOK ? (rw.y < headY + wristUpMargin || rw.y < shoulderY - 0.010) : false;

  const leftElbowUp  = leOK ? (le.y < shoulderY - elbowUpMargin) : false;
  const rightElbowUp = reOK ? (re.y < shoulderY - elbowUpMargin) : false;

  const leftScore  = leftWristUp  ? 1.0 : (leftElbowUp  ? 0.70 : 0.0);
  const rightScore = rightWristUp ? 1.0 : (rightElbowUp ? 0.70 : 0.0);

  // Wenn nur ein Arm verwertbar ist, nimm den (max), aber verhindere,
  // dass "gar nichts" durch Occlusion künstlich 0 bleibt:
  return Math.max(leftScore, rightScore);
}


function legsStraightScore(raw) {
  const lh = raw[23], rh = raw[24], lk = raw[25], rk = raw[26], la = raw[27], ra = raw[28];
  const aL = kneeAngle(lh, lk, la);
  const aR = kneeAngle(rh, rk, ra);

  const toScore = (ang) => {
    if (ang == null) return 0;
    if (ang <= 145) return 0;
    if (ang >= 170) return 1;
    return (ang - 145) / (170 - 145);
  };

  if (aL != null && aR != null) return Math.min(toScore(aL), toScore(aR));
  return Math.max(toScore(aL), toScore(aR));
}

function bodyLongScore(raw) {
  const ls = raw[11], rs = raw[12], lh = raw[23], rh = raw[24];
  if (!ls || !rs || !lh || !rh) return 0;
  const sh = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };
  const hp = { x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2 };
  const d = dist(sh, hp);
  if (d <= 0.10) return 0;
  if (d >= 0.14) return 1;
  return (d - 0.10) / (0.14 - 0.10);
}

function stillnessScore(raw) {
  const ls = raw[11], rs = raw[12], lh = raw[23], rh = raw[24];
  if (!ls || !rs || !lh || !rh) return 0;

  const sh = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };
  const hp = { x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2 };
  const torso = { x:(sh.x+hp.x)/2, y:(sh.y+hp.y)/2 };

  const p = filmingPreset.value;
  const tol = (p === "side45") ? 0.014 : 0.012;

  if (!lastTorso) { lastTorso = torso; return 0.3; }
  const move = Math.hypot(torso.x - lastTorso.x, torso.y - lastTorso.y);
  lastTorso = torso;

  const s = 1 - Math.min(1, move / tol);
  return Math.max(0, s);
}

function computeGlideScore(raw) {
  const arms = armOverHeadRobust(raw);
  const legs = legsStraightScore(raw);
  const longB = bodyLongScore(raw);
  const still = stillnessScore(raw);
  return (0.38*arms + 0.32*legs + 0.18*longB + 0.12*still);
}

function resetTimerState(alsoSlots=false){
  glideActive = false; glideStart = 0; currentElapsed = 0;
  scoreEma = 0; scoreStableSince = null;

  stopScoreSince = null;
  stopMoveSince  = null;
  ignoreStopUntil = 0;

  lastTorso = null;
  if(alsoSlots) glideTimes.length = 0;
}

function updateTimer(raw, now, isRecording){
  if(!toggleTimer.checked){ resetTimerState(false); return; }
  if(!isRecording){ resetTimerState(false); return; }

  const p = filmingPreset.value;

  const startThr = (p === "side45") ? 0.69 : 0.75;
  const stopThr  = (p === "side45") ? 0.55 : 0.58;

  const startHoldMs = (p === "side45") ? 110 : 160;
  const stopHoldMs  = (p === "side45") ? 220 : 230;

  const hardMaxMs = (p === "stand") ? 5000 : 6500;
  const alpha = (p === "side45") ? 0.62 : 0.60;

  const sNow = computeGlideScore(raw);
  if (scoreEma === 0) scoreEma = sNow;
  else scoreEma = alpha*scoreEma + (1-alpha)*sNow;

  // STOP-Signale
  const lh = raw[23], rh = raw[24], lk = raw[25], rk = raw[26], la = raw[27], ra = raw[28];
  const aL = kneeAngle(lh, lk, la);
  const aR = kneeAngle(rh, rk, ra);

  const kneesBend = ((aL != null && aL < 158) || (aR != null && aR < 158));
  const armScore = armOverHeadRobust(raw);
  const armsDropped = armScore < 0.48;
  const movementStop = kneesBend || armsDropped;

  // START
  if(!glideActive){
    currentElapsed = 0;

    if(scoreEma >= startThr && glideTimes.length < 4){
      if(scoreStableSince == null) scoreStableSince = now;

      if(now - scoreStableSince >= startHoldMs){
        glideActive = true;
        glideStart = now;

        stopScoreSince = null;
        stopMoveSince  = null;
        scoreStableSince = null;

        ignoreStopUntil = now + ((p === "side45") ? 220 : 260);
      }
    } else {
      scoreStableSince = null;
    }
    return;
  }

  // RUN
  currentElapsed = now - glideStart;

  if(currentElapsed >= hardMaxMs){
    glideActive = false;
    stopScoreSince = null;
    stopMoveSince  = null;
    if(glideTimes.length < 4) glideTimes.push(currentElapsed);
    currentElapsed = 0;
    return;
  }

  if(now < ignoreStopUntil) return;

  // STOP 1: Bewegung (schnell)
  if(movementStop){
    if(stopMoveSince == null) stopMoveSince = now;

    if(now - stopMoveSince >= 90){
      glideActive = false;
      stopScoreSince = null;
      stopMoveSince  = null;
      if(glideTimes.length < 4) glideTimes.push(now - glideStart);
      currentElapsed = 0;
      return;
    }

  } else {
    stopMoveSince = null;
  }

  // STOP 2: Score unter Schwelle (mit Hold)
  if(scoreEma <= stopThr){
    if(stopScoreSince == null) stopScoreSince = now;

    if(now - stopScoreSince >= stopHoldMs){
      glideActive = false;
      stopScoreSince = null;
      stopMoveSince  = null;
      if(glideTimes.length < 4) glideTimes.push(now - glideStart);
      currentElapsed = 0;
      return;
    }

  } else {
    stopScoreSince = null;
  }
}

// Hand-axis drawing + measurement (GATED: only when NOT glideActive)
function drawHandAxis(raw, cssPoints) {
  if (toggleTimer.checked && glideActive) return { handRatio: null, gated: true };

  if (!toggleHandAxis.checked || !raw || !cssPoints) return { handRatio: null, gated: false };

  const wL = cssPoints[15];
  const wR = cssPoints[16];
  const sL = cssPoints[11], sR = cssPoints[12];

  const okVis = (p)=> (p && (typeof p.visibility !== "number" || p.visibility >= 0.20));
  if (!wL || !wR || !sL || !sR || !okVis(wL) || !okVis(wR) || !okVis(sL) || !okVis(sR)) {
    return { handRatio: null, gated: false };
  }

  const shoulderW = distXPx(sL, sR);
  const handW = distXPx(wL, wR);
  const handRatio = (shoulderW > 1) ? (handW / shoulderW) : null;

  if (handRatio != null) {
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineWidth = 3;
    ctx.setLineDash([7, 6]);
    ctx.strokeStyle = colorForHandRatio(handRatio);
    ctx.beginPath();
    ctx.moveTo(wL._cx, wL._cy);
    ctx.lineTo(wR._cx, wR._cy);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  return { handRatio, gated: false };
}

// Overlay + debug footer
const DEBUG_ENABLED = false;

function drawOverlay(debugText=""){
  if(!toggleTimer.checked) {
    if (DEBUG_ENABLED && debugText) drawDebugFooter(debugText);
    return;
  }

  const isPortrait = CSS_H > CSS_W;
  const x = 12, y = 12;
  const w = isPortrait ? Math.min(420, CSS_W-24) : Math.min(680, CSS_W-24);
  const h = isPortrait ? 140 : 90;
  const r = 14;

  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.40)";
  ctx.strokeStyle="rgba(255,255,255,0.55)";
  ctx.lineWidth=2;

  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  ctx.fillStyle="white";

  // 1) große Zeit
  ctx.font = isPortrait ? "800 24px system-ui" : "800 20px system-ui";
  ctx.fillText(glideActive ? fmt(currentElapsed) : "0.000 s", x+12, y+(isPortrait?34:28));

  // 2) Titel klein
  ctx.font = isPortrait ? "700 13px system-ui" : "700 12.5px system-ui";
  ctx.fillText("Timer – Gleitphase", x+12, y+(isPortrait?54:46));

  if (isPortrait) {
    const baseY = y + 80;
    for (let i=0;i<4;i++){
      const t = glideTimes[i]!=null ? fmt(glideTimes[i]) : "—";
      ctx.fillText(`Slot ${i+1}: ${t}`, x+12, baseY + i*16);
    }
  } else {
    const lineY = y + 72;
    const parts = [];
    for (let i=0;i<4;i++){
      const t = glideTimes[i]!=null ? fmt(glideTimes[i]) : "—";
      parts.push(`S${i+1}: ${t}`);
    }
    let cx = x + 12;
    for (const p of parts) {
      ctx.fillText(p, cx, lineY);
      cx += ctx.measureText(p).width + 18;
      if (cx > x + w - 80) break;
    }
  }

  ctx.restore();
  if (DEBUG_ENABLED && debugText) drawDebugFooter(debugText);
}

function drawDebugFooter(text) {
  const pad = 8;
  const h = 18;
  const y = CSS_H - h - 10;
  const w = Math.min(CSS_W - 24, 980);
  const x = 12;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(x, y, w, h, 8);
  else {
    ctx.moveTo(x+8,y); ctx.arcTo(x+w,y,x+w,y+h,8); ctx.arcTo(x+w,y+h,x,y+h,8); ctx.arcTo(x,y+h,x,y,8); ctx.arcTo(x,y,x+w,y,8); ctx.closePath();
  }
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.font = "11px system-ui";
  ctx.fillText(text, x + pad, y + 13);
  ctx.restore();
}

if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    this.beginPath();
    this.moveTo(x+rr, y);
    this.arcTo(x+w, y, x+w, y+h, rr);
    this.arcTo(x+w, y+h, x, y+h, rr);
    this.arcTo(x, y+h, x, y, rr);
    this.arcTo(x, y, x+w, y, rr);
    this.closePath();
    return this;
  };
}

// Recording + tips
let recorder=null, recordedChunks=[], lastBlob=null;
let isRecording = false;
let isFinalizingStop = false;

// Post-Stop Tips Overlay (wird im Video mit aufgenommen)
let showTipsOverlayUntil = 0;
let tipsOverlayLines = [];
let tipsOverlayTitle = "Techniktipps (Brust)";

function drawTipsOverlay(nowTs){
  if (!showTipsOverlayUntil || nowTs > showTipsOverlayUntil) return;
  if (!tipsOverlayLines || tipsOverlayLines.length === 0) return;

  const isPortrait = CSS_H > CSS_W;
  const pad = 12;
  const boxW = Math.min(CSS_W - 24, isPortrait ? 520 : 860);
  const x = 12;
  const lineH = isPortrait ? 18 : 16;

  // Titel + bis zu 4/3 Tipps
  const maxLines = isPortrait ? 5 : 4;
  const lines = [tipsOverlayTitle, ...tipsOverlayLines.slice(0, maxLines - 1)];

  const boxH = pad*2 + 10 + lines.length*lineH;
  const y = Math.max(12, CSS_H - boxH - 12);

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 2;

  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(x, y, boxW, boxH, 14);
  else {
    const r=14,w=boxW,h=boxH;
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }
  ctx.fill(); ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.font = (isPortrait ? "800 14px system-ui" : "800 13px system-ui");
  ctx.fillText(lines[0], x+pad, y+pad+14);

  ctx.font = (isPortrait ? "13px system-ui" : "12.5px system-ui");
  let ty = y + pad + 14 + 8;
  for (let i=1;i<lines.length;i++){
    ty += lineH;
    ctx.fillText(lines[i], x+pad, ty);
  }
  ctx.restore();
}

// ✅ State für Timing/Events
let prevIsPullPhase = false;
let lastArmEndTs = null;
let lastHandsForwardTs = null;

// Hand detection
let prevHandTooWide = false;
const HAND_RED_THR = 2.50;

// HWS extension streak
let headExtStreakStart = null;

// ✅ weniger sensibel: "zu tief" nur wenn über mehrere Frames wirklich auf/unter Hüfte
let deepStreak = 0;

const recStats = {
  frames: 0,

  kneeWide: 0,
  kneeAsym: 0,
  legsBent: 0,
  avgKneeRatioSum: 0,
  avgKneeRatioN: 0,

  headExtAny: 0,
  headExtStreakMsMax: 0,
  headFlex: 0,

  armPullFrames: 0,
  handWideFrames: 0,
  handWideEvents: 0,
  armTooDeepFrames: 0,
  streamlineGoodFrames: 0,

  lateKickEvents: 0,
  lateKickDelaySumMs: 0,
  lateKickDelayN: 0
};

function resetRecStats() {
  for (const k of Object.keys(recStats)) recStats[k] = 0;

  prevHandTooWide = false;
  headExtStreakStart = null;
  recStats.headExtStreakMsMax = 0;

  prevIsPullPhase = false;
  lastArmEndTs = null;
  lastHandsForwardTs = null;

  deepStreak = 0;
}

function clearTipsUI() {
  tipsBox.style.display = "none";
  hintList.innerHTML = "";
  hintText.textContent = "";
  hintMeta.textContent = "";
}

function getTopIssuesUnified(maxN = 3) {
  if (!toggleHintBox.checked) return { meta:"", intro:"", issues:[] };

  if (recStats.frames < 25) {
    return {
      meta: `${recStats.frames} Frames`,
      intro: "Aufnahme war sehr kurz – bitte länger filmen.",
      issues: [{
        score: 1,
        title: "Aufnahme zu kurz",
        tip: "Bitte länger filmen (mehrere Zyklen) + stabile Perspektive."
      }].slice(0, maxN)
    };
  }

  const p = (n)=> n / Math.max(1, recStats.frames);
  const thr = 0.16;
  const issues = [];

    const kneeShare = p(recStats.kneeWide);
  if (kneeShare >= 0.14)
  issues.push({
    score: kneeShare,
    title:"Knie ziehen zu breit an (Rückholphase)",
    tip:"Knie schmal (≈ schulterbreit) anziehen. Rückholen kompakt – Kick dann kräftig nach hinten."
  });

  if (filmingPreset.value==="back45" && p(recStats.kneeAsym) >= thr)
    issues.push({score:p(recStats.kneeAsym), title:"Beinschere (Asymmetrie)", tip:"Beinbewegung links/rechts wirkte über mehrere Frames asymmetrisch."});

  if (p(recStats.legsBent) >= thr)
    issues.push({score:p(recStats.legsBent), title:"Beine nicht gestreckt in der Gleitphase", tip:"Nach dem Beinschlag vollständig strecken und kurz stabil gleiten."});

  const armPullDen = Math.max(1, recStats.armPullFrames);
  const handWideShare = recStats.handWideFrames / armPullDen;
  if (recStats.handWideEvents >= 2 || handWideShare >= 0.18)
    issues.push({score:Math.max(0.38, handWideShare), title:"Armzug sehr breit", tip:"Hände weniger weit nach außen öffnen."});

  const deepShare = recStats.armTooDeepFrames / armPullDen;
  if (deepShare >= 0.22 && recStats.armPullFrames >= 14)
    issues.push({score:deepShare, title:"Hände ziehen zu tief", tip:"Hände beim Armzug nur bis ca. auf Brusthöhe ziehen dann wieder in die Streckung."});

  const streamShare = recStats.streamlineGoodFrames / Math.max(1, recStats.frames);
  if (streamShare <= 0.12 && recStats.frames >= 40)
    issues.push({score:Math.min(1,(0.16-streamShare)/0.16), title:"Streck-/Stromlinienphase fehlt", tip:"Nach dem Arbeiten klare Stromlinienhaltung herstellen (schlank machen)."});

  if (recStats.lateKickEvents >= 2)
    issues.push({score:0.5, title:"Beinschlag übernimmt zu spät", tip:"Kick startet, wenn die Hände wieder nach vorn gehen."});

  issues.sort((a,b)=>b.score-a.score);
  return {
    meta: `${recStats.frames} Frames`,
    intro: "In dieser Aufnahme waren folgende Punkte auffällig:",
    issues: issues.slice(0, maxN)
  };
}

function showTechTipsFromStats() {
  clearTipsUI();

  const pack = getTopIssuesUnified(3);
  if (!pack.issues || pack.issues.length === 0) return;

  hintMeta.textContent = pack.meta;
  hintText.textContent = pack.intro;

  for (const it of pack.issues) {
    const li = document.createElement("li");
    li.innerHTML = `<b>${it.title}</b> – ${it.tip}`;
    hintList.appendChild(li);
  }
  tipsBox.style.display = "block";
}

function buildOverlayTipsFromStats() {
  const pack = getTopIssuesUnified(3);

  if (!pack.issues || pack.issues.length === 0) {
    return [
      "• Keine klaren Auffälligkeiten erkannt.",
      "• Tipp: länger filmen + stabile Perspektive."
    ];
  }
  return pack.issues.map(it => `• ${it.title} – ${it.tip}`);
}

function pickMimeType(){
  const candidates=[
    'video/mp4;codecs="avc1.42E01E"',
    'video/mp4;codecs="avc1.4D401E"',
    "video/mp4",
    'video/webm;codecs="vp8"',
    "video/webm"
  ];
  if(!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
  for(const t of candidates){ try{ if(MediaRecorder.isTypeSupported(t)) return t; } catch(_){} }
  return "";
}

function startRecordingCanvas(){
  recordedChunks=[]; lastBlob=null; btnShare.disabled=true;
  resetRecStats();
  isRecording = true;

  resetTimerState(true);
  clearTipsUI();

  const s = canvas.captureStream(15);
  const mt = pickMimeType();
  try{ recorder=new MediaRecorder(s, mt?{mimeType:mt}:undefined); }
  catch(_){ recorder=new MediaRecorder(s); }

  setStatus("Aufnahme läuft… (" + (recorder.mimeType || mt || "default") + ")");
  recorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
  recorder.onstop=()=>{
    isRecording = false;
    const type = recorder.mimeType || mt || "video/webm";
    lastBlob = new Blob(recordedChunks,{type});
    btnShare.disabled = !lastBlob;
    setStatus("Aufnahme fertig (" + (lastBlob.type.includes("mp4") ? "MP4" : "WebM") + ").");
    showTechTipsFromStats();
  };
  recorder.start(200);
}

function stopRecordingCanvas(){ if(recorder && recorder.state!=="inactive") recorder.stop(); }

async function shareOrDownload(){
  try{
    if(!lastBlob){
      setStatus("Kein Video vorhanden (erst aufnehmen & stoppen).");
      return;
    }

    const type = lastBlob.type || "video/webm";
    const ext  = type.includes("mp4") ? "mp4" : (type.includes("webm") ? "webm" : "bin");
    const fileName = `bewegungsanalyse_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
    const file = new File([lastBlob], fileName, { type });

    const isDesktop =
      matchMedia("(pointer:fine)").matches &&
      !/Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    if (!isDesktop && navigator.share && navigator.canShare) {
      let can = false;
      try { can = navigator.canShare({ files: [file] }); } catch(_) {}
      if (can) {
        await navigator.share({ files:[file], title:"Anonyme Bewegungsanalyse" });
        setStatus("Geteilt/gespeichert.");
        return;
      }
    }

    const url = URL.createObjectURL(lastBlob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fileName;
    a.rel = "noopener";
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => {
      try { window.open(url, "_blank", "noopener,noreferrer"); } catch(_) {}
    }, 250);

    setTimeout(()=>URL.revokeObjectURL(url), 8000);
    setStatus("Speichern gestartet (" + ext.toUpperCase() + ").");

  } catch (e) {
    console.error("shareOrDownload error:", e);
    setStatus("Teilen/Speichern fehlgeschlagen: " + (e?.message || String(e)));
  }
}

// MediaPipe
let landmarker = null;
let running = false;
let rafId = null;

const POSE_TASK_URL =
  "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task";

async function createLandmarker(){
  setStatus("Lade Tasks-WASM …");
  const fileset = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
  );

  setStatus("Lade Pose Landmarker heavy …");
  landmarker = await PoseLandmarker.createFromOptions(fileset, {
    baseOptions: { modelAssetPath: POSE_TASK_URL },
    runningMode: "VIDEO",
    numPoses: 1,
    outputSegmentationMasks: true,
    minPoseDetectionConfidence: Number(detConf.value),
    minPosePresenceConfidence: Number(presConf.value),
    minTrackingConfidence: Number(trackConf.value),
  });
}

function updateLandmarkerThresholds(){
  if(!landmarker) return;
  landmarker.setOptions({
    minPoseDetectionConfidence: Number(detConf.value),
    minPosePresenceConfidence: Number(presConf.value),
    minTrackingConfidence: Number(trackConf.value),
  });
  setStatus("Schwellwerte aktualisiert.");
}
detConf.addEventListener("change", updateLandmarkerThresholds);
presConf.addEventListener("change", updateLandmarkerThresholds);
trackConf.addEventListener("change", updateLandmarkerThresholds);

// Camera
let isBackCamera = true;
let stream = null;

async function startCamera(){
  stopCamera();
  stream = await navigator.mediaDevices.getUserMedia({
    audio:false,
    video:{
      facingMode: isBackCamera ? "environment" : "user",
      width:{ideal:1280},
      height:{ideal:720}
    }
  });
  video.srcObject = stream;

  await new Promise((resolve)=>{
    const done=()=>resolve();
    if(video.readyState>=1) return done();
    video.onloadedmetadata = done;
  });
  await video.play();

  await new Promise((resolve)=>{
    const check=()=> (video.videoWidth>0 && video.videoHeight>0) ? resolve() : requestAnimationFrame(check);
    check();
  });
}

function stopCamera(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.srcObject=null;
}

/* =========================
ARMZUG – PHASENERKENNUNG
========================= */
function isPullPhaseHeuristic(raw){
  const ls = raw[11], rs = raw[12];
  const le = raw[13], re = raw[14];
  const lw = raw[15], rw = raw[16];
  if(!ls || !rs) return false;

  const shoulderY = (ls.y + rs.y) / 2;

  // Streamline → KEINE Zugphase
  if (armOverHeadRobust(raw) > 0.55) return false;

  const eL = elbowAngle(ls, le, lw);
  const eR = elbowAngle(rs, re, rw);

  const wristDownL = lw ? (lw.y > shoulderY + 0.035) : false;
  const wristDownR = rw ? (rw.y > shoulderY + 0.035) : false;

  const elbowBentL = (eL != null) ? (eL < 165) : false;
  const elbowBentR = (eR != null) ? (eR < 165) : false;

  return ( (wristDownL && elbowBentL) || (wristDownR && elbowBentR) );
}

/* =========================
HÄNDE ZU TIEF – EXTREM KONSERVATIV
========================= */
function wristsTooDeep(raw){
  const ls = raw[11], rs = raw[12];
  const lh = raw[23], rh = raw[24];
  const lw = raw[15], rw = raw[16];

  if (!ls || !rs || !lh || !rh || (!lw && !rw)) return false;

  const sh = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };
  const hp = { x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2 };

  let ax = { x: hp.x - sh.x, y: hp.y - sh.y };
  const L = Math.hypot(ax.x, ax.y);
  if (L < 1e-6) return false;
  ax = { x: ax.x / L, y: ax.y / L };

  const proj = (p) => ( (p.x - sh.x)*ax.x + (p.y - sh.y)*ax.y );
  const hipT = proj(hp);

  const margin = 0.10 * L;

  const leftDeep  = lw ? (proj(lw) >= hipT - margin) : false;
  const rightDeep = rw ? (proj(rw) >= hipT - margin) : false;

  return leftDeep || rightDeep;
}

/* =========================
STROMLINIE – bewusst konservativ
========================= */
function isStreamlineGood(raw){
  if(!raw) return false;
  const arms = armOverHeadRobust(raw);
  const legs = legsStraightScore(raw);
  return (arms >= 0.72) && (legs >= 0.72);
}

// Loop
let emptyMaskFrames = 0;

function loop(){
  if(!running || !landmarker) return;

  try{
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, CSS_W, CSS_H);

    if(video.videoWidth===0 || video.videoHeight===0){
      drawOverlay("DEBUG: video not ready");
      rafId = requestAnimationFrame(loop);
      return;
    }

    const ts = performance.now();
    const result = landmarker.detectForVideo(video, ts);
    drawTipsOverlay(ts);

    const hasMask = !!(result?.segmentationMasks?.length);
    const hasLandmarks = !!(result?.landmarks?.length && result.landmarks[0]?.length);

    let maskInfo = { max: 0 };
    if (hasMask) {
      // ✅ perf: throttled + cached
      maskInfo = drawSilhouette(result.segmentationMasks[0], ts);

      if ((maskInfo.max ?? 0) <= 0.001) emptyMaskFrames++;
      else emptyMaskFrames = 0;

      if (emptyMaskFrames > 45) {
        toggleSilhouette.checked = false;
        setStatus("Hinweis: Segmentierung liefert leere Werte → deaktiviert.");
      }
    }

    if (hasLandmarks) {
      const raw = result.landmarks[0];
      const vw = video.videoWidth, vh = video.videoHeight;
      const cssPoints = emaCss(mapLandmarksContain(raw, vw, vh, CSS_W, CSS_H));

      drawSkeletonCssPoints(cssPoints);

      const neck = drawNeckAxis(raw, cssPoints, ts);
      const legs = drawLegChecks(raw, cssPoints);

      updateTimer(raw, ts, isRecording && !isFinalizingStop);
      const hands = drawHandAxis(raw, cssPoints);

      // =========================
      // ✅ REC STATS (läuft nur während Aufnahme)
      // =========================
      if (isRecording && !isFinalizingStop) {
        recStats.frames++;

                if (legs.valid && legs.kneeRatio != null) {
          recStats.avgKneeRatioSum += legs.kneeRatio;
          recStats.avgKneeRatioN++;
        
          // Strenger/robuster: schon ab ~amber/upper-amber mitzählen,
          // damit kurze "rote" Phasen nicht untergehen.
          // (passt zu deiner Farblogik: green<=1.35, amber<=1.55, red>1.55)
          const kneeWideThr = (filmingPreset.value === "side45") ? 1.48 : 1.50;
          if (legs.kneeRatio > kneeWideThr) recStats.kneeWide++;
        }


        if (filmingPreset.value !== "side45" && legs.valid) {
          if (legs.kneeDiff != null && legs.kneeDiff > 25) recStats.kneeAsym++;
        }

        if (toggleTimer.checked && glideActive && legs.valid) {
          const [aL, aR] = legs.kneeAngles || [null,null];
          const bent = ((aL != null && aL < 155) || (aR != null && aR < 155));
          if (bent) recStats.legsBent++;
        }

        if (isStreamlineGood(raw)) recStats.streamlineGoodFrames++;

        if (toggleTimer.checked && glideActive && neck?.profile && neck?.state) {
          if (neck.state === "redFlex") recStats.headFlex++;
          if (neck.state === "redExt") {
            recStats.headExtAny++;
            if (headExtStreakStart == null) headExtStreakStart = ts;
            const streak = ts - headExtStreakStart;
            if (streak > recStats.headExtStreakMsMax) recStats.headExtStreakMsMax = streak;
          } else {
            headExtStreakStart = null;
          }
        } else {
          headExtStreakStart = null;
        }

        const pullPhase = (!glideActive) && isPullPhaseHeuristic(raw);

        if (pullPhase) {
          recStats.armPullFrames++;

          // ✅ "zu tief" nur, wenn 3 Frames am Stück wirklich unter Hüfte
          if (wristsTooDeep(raw)) deepStreak++;
          else deepStreak = 0;

          if (deepStreak >= 3) recStats.armTooDeepFrames++;

          if (hands.handRatio != null) {
            const tooWideNow = hands.handRatio > HAND_RED_THR;
            if (tooWideNow && !prevHandTooWide) recStats.handWideEvents++;
            prevHandTooWide = tooWideNow;
            if (tooWideNow) recStats.handWideFrames++;
          } else {
            prevHandTooWide = false;
          }
        } else {
          prevHandTooWide = false;
          deepStreak = 0;
        }

        // ===== Timing Hände-vor → Kick (lateKick) – ULTRA-ROBUST (occlusion-safe) =====
        if (typeof window.__lk_prevKneeAL === "undefined") window.__lk_prevKneeAL = null;
        if (typeof window.__lk_prevKneeAR === "undefined") window.__lk_prevKneeAR = null;
        if (typeof window.__lk_prevAnkleLX === "undefined") window.__lk_prevAnkleLX = null;
        if (typeof window.__lk_prevAnkleLY === "undefined") window.__lk_prevAnkleLY = null;
        if (typeof window.__lk_prevAnkleRX === "undefined") window.__lk_prevAnkleRX = null;
        if (typeof window.__lk_prevAnkleRY === "undefined") window.__lk_prevAnkleRY = null;
        if (typeof window.__lk_prevTs === "undefined") window.__lk_prevTs = null;

        // 1) Armzug-Ende merken
        const pullPhaseNow = (!glideActive) && isPullPhaseHeuristic(raw);
        if (prevIsPullPhase && !pullPhaseNow) {
          lastArmEndTs = ts;
          lastHandsForwardTs = null;
        }
        prevIsPullPhase = pullPhaseNow;

        // 2) Hände wieder klar vorn (echte Streckung) erkennen
        if (lastArmEndTs != null && lastHandsForwardTs == null) {
          const oh = armOverHeadRobust(raw);       // 0..1
          const legS = legsStraightScore(raw);     // 0..1
          const withinWindow = (ts - lastArmEndTs) <= 1100;

          if (withinWindow && oh >= 0.68 && legS >= 0.58) {
            lastHandsForwardTs = ts;
          }
        }

        // 3) Kick-Start robust erkennen (Knie-Flex-Drop ODER Ankle-Speed)
        const okVisRaw = (p) => (p && (typeof p.visibility !== "number" || p.visibility >= 0.25));

        const lh = raw[23], rh = raw[24];
        const lk = raw[25], rk = raw[26];
        const la = raw[27], ra = raw[28];

        const aL = (lh && lk && la) ? kneeAngle(lh, lk, la) : null;
        const aR = (rh && rk && ra) ? kneeAngle(rh, rk, ra) : null;

        const prevAL = window.__lk_prevKneeAL;
        const prevAR = window.__lk_prevKneeAR;

        const DROP_DEG = 10;
        const KICK_ANG = 154;

        const kneeDropL = (aL != null && prevAL != null && (prevAL - aL) >= DROP_DEG && aL < KICK_ANG);
        const kneeDropR = (aR != null && prevAR != null && (prevAR - aR) >= DROP_DEG && aR < KICK_ANG);

        const prevTs = window.__lk_prevTs;
        const dt = (prevTs != null) ? Math.max(1, ts - prevTs) : null;

        let ankleSpeedHit = false;
        if (dt != null) {
          if (la && okVisRaw(la) && window.__lk_prevAnkleLX != null && window.__lk_prevAnkleLY != null) {
            const vx = (la.x - window.__lk_prevAnkleLX) / dt;
            const vy = (la.y - window.__lk_prevAnkleLY) / dt;
            const v = Math.hypot(vx, vy);
            if (v > 0.00011) ankleSpeedHit = true;
          }
          if (ra && okVisRaw(ra) && window.__lk_prevAnkleRX != null && window.__lk_prevAnkleRY != null) {
            const vx = (ra.x - window.__lk_prevAnkleRX) / dt;
            const vy = (ra.y - window.__lk_prevAnkleRY) / dt;
            const v = Math.hypot(vx, vy);
            if (v > 0.00011) ankleSpeedHit = true;
          }
        }

        const kickStartNow = (kneeDropL || kneeDropR || ankleSpeedHit);

        // prev state updaten
        window.__lk_prevKneeAL = aL;
        window.__lk_prevKneeAR = aR;

        window.__lk_prevTs = ts;
        if (la && okVisRaw(la)) { window.__lk_prevAnkleLX = la.x; window.__lk_prevAnkleLY = la.y; }
        if (ra && okVisRaw(ra)) { window.__lk_prevAnkleRX = ra.x; window.__lk_prevAnkleRY = ra.y; }

        // 4) Delay auswerten (konservativ)
        if (lastHandsForwardTs != null) {
          if ((ts - lastHandsForwardTs) > 1850) {
            lastHandsForwardTs = null;
            lastArmEndTs = null;
          } else if (kickStartNow) {
            const delay = ts - lastHandsForwardTs;

            if (delay > 800 && delay < 1550) {
              recStats.lateKickEvents++;
              recStats.lateKickDelaySumMs += delay;
              recStats.lateKickDelayN++;
            }

            lastHandsForwardTs = null;
            lastArmEndTs = null;
          }
        }

      } // ✅ Recording-Block Ende

      drawOverlay(
        `DEBUG: mask=${hasMask?1:0} maskmax=${(maskInfo.max??0).toFixed(3)} score=${scoreEma.toFixed(2)} rec=${isRecording?1:0} preset=${filmingPreset.value}`
      );

    } else {
      drawOverlay(`DEBUG: lm=0 mask=${hasMask?1:0} maskmax=${(maskInfo.max??0).toFixed(3)} rec=${isRecording?1:0}`);
    }

    rafId = requestAnimationFrame(loop);

  } catch(e){
    console.error(e);
    setStatus("Loop-Fehler: " + (e?.message || String(e)));
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, CSS_W, CSS_H);
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = "16px system-ui";
    ctx.fillText("Loop-Fehler: " + (e?.message || String(e)), 20, 40);
  }
}

// Buttons
btnInit.addEventListener("click", async ()=>{
  try{
    btnInit.disabled=true;
    applyLayoutFromOrientation();
    setStatus("Initialisiere …");

    await startCamera();
    await createLandmarker();

    running=true;
    btnSwitch.disabled=false;
    btnRec.disabled=false;
    btnReset.disabled=false;

    clearTipsUI();
    emptyMaskFrames = 0;
    resetNeckState();
    resetTimerState(true);

    // ✅ PERF: reset mask cache state
    lastMaskBuildTs = 0;
    lastMaskMax = 0;
    hasCachedMask = false;

    setStatus("bereit.");
    rafId = requestAnimationFrame(loop);

  } catch(e){
    console.error(e);
    setStatus("Fehler: " + (e?.message || String(e)));
    btnInit.disabled=false;
  }
});

btnSwitch.addEventListener("click", async ()=>{
  try{
    btnSwitch.disabled=true;
    running=false;
    if(rafId) cancelAnimationFrame(rafId);

    isBackCamera=!isBackCamera;
    await startCamera();

    smoothedCss = null;
    emptyMaskFrames = 0;

    clearTipsUI();
    resetNeckState();
    resetTimerState(true);

    // ✅ PERF: reset mask cache state (sonst stale)
    lastMaskBuildTs = 0;
    lastMaskMax = 0;
    hasCachedMask = false;

    running=true;
    rafId = requestAnimationFrame(loop);

    btnSwitch.disabled=false;
    setStatus("Kamera gewechselt.");

  } catch(e){
    console.error(e);
    setStatus("Kamerawechsel-Fehler: " + (e?.message || String(e)));
    running=true;
    rafId = requestAnimationFrame(loop);
    btnSwitch.disabled=false;
  }
});

btnRec.addEventListener("click", ()=>{
  btnRec.disabled=true;
  btnStop.disabled=false;
  startRecordingCanvas();
});

btnStop.addEventListener("click", ()=>{
  btnStop.disabled = true;

  isFinalizingStop = true;

  tipsOverlayTitle = "Techniktipps (Brust)";
  const lines = buildOverlayTipsFromStats();

  tipsOverlayLines = (lines.length > 0)
    ? lines
    : [
      "• Keine klaren Auffälligkeiten erkannt.",
      "• Tipp: länger filmen + stabile Perspektive."
    ];

  showTipsOverlayUntil = performance.now() + 3000;

  setTimeout(() => {
    stopRecordingCanvas();
    btnRec.disabled = false;
    isFinalizingStop = false;
  }, 3000);
});

btnShare.addEventListener("click", (e) => {
  e.preventDefault();
  shareOrDownload();
});

btnReset.addEventListener("click", ()=>{
  resetTimerState(true);
  setStatus("Slots zurückgesetzt.");
  clearTipsUI();
  resetNeckState();
});

// Feedback: Meta automatisch füllen + async submit (ohne Seiten-Reload)
function buildFeedbackMeta() {
  const parts = [];
  parts.push(`preset=${filmingPreset.value}`);
  parts.push(`timer=${toggleTimer.checked?1:0}`);
  parts.push(`skel=${toggleSkeleton.checked?1:0}`);
  parts.push(`sil=${toggleSilhouette.checked?1:0}`);
  parts.push(`det=${Number(detConf.value).toFixed(2)}`);
  parts.push(`pres=${Number(presConf.value).toFixed(2)}`);
  parts.push(`track=${Number(trackConf.value).toFixed(2)}`);
  parts.push(`ua=${navigator.userAgent}`);
  parts.push(`ui=${isPortraitUI()?"portrait":"landscape"}`);
  return parts.join(" | ");
}

feedbackForm?.addEventListener("submit", async (ev) => {
  ev.preventDefault();

  fbMeta.value = buildFeedbackMeta();
  fbStatus.className = "fbStatus";
  fbStatus.style.display = "block";
  fbStatus.textContent = "Sende …";

  try {
    const formData = new FormData(feedbackForm);
    const resp = await fetch(feedbackForm.action, {
      method: "POST",
      body: formData,
      headers: { "Accept": "application/json" }
    });

    if (resp.ok) {
      fbStatus.className = "fbStatus ok";
      fbStatus.textContent = "Danke! Feedback wurde gesendet.";
      feedbackForm.reset();
    } else {
      fbStatus.className = "fbStatus err";
      fbStatus.textContent = "Senden fehlgeschlagen. Bitte später erneut versuchen.";
    }

  } catch (e) {
    fbStatus.className = "fbStatus err";
    fbStatus.textContent = "Netzwerkfehler. Bitte später erneut versuchen.";
  }
});
</script>
</body>
</html>
