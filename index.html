<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pose Recorder (Skelett + Silhouette)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    video, canvas { max-width: 100%; width: 480px; height: auto; border: 1px solid #ddd; border-radius: 10px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button.primary { border-color: #111; }
    button:disabled { opacity: 0.5; }
    label { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; }
    .hint { color: #555; font-size: 14px; line-height: 1.4; max-width: 920px; }
    .small { font-size: 13px; color: #666; }
  </style>

  <!-- MediaPipe (klassisch, ohne ES-Module) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
</head>

<body>
  <h1>Pose Recorder (nur Canvas-Video)</h1>
  <p class="hint">
    Links: Live-Kamera (nur zur Erkennung). Rechts: Canvas (wird gespeichert) mit Skelett und optional anonymer Silhouette.
    Gespeichert wird nur das Canvas-Video, nicht das Kamerabild.
  </p>

  <div class="row">
    <button id="btnInit" class="primary">Kamera aktivieren (Rückkamera)</button>
    <button id="btnRec" disabled>Aufnahme starten</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnShare" disabled>Teilen/Speichern</button>
  </div>

  <div class="row">
    <label>
      <input type="checkbox" id="toggleSilhouette" checked />
      Silhouette (anonym) einblenden
    </label>
    <span class="small">Tipp: Bei flackernder Silhouette im Schwimmbad deaktivieren.</span>
  </div>

  <div class="row">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <p class="hint" id="status">Status: bereit</p>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const btnInit = document.getElementById("btnInit");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const statusEl = document.getElementById("status");
    const toggleSilhouette = document.getElementById("toggleSilhouette");

    function setStatus(s) { statusEl.textContent = "Status: " + s; }

    // -----------------------------
    // Recording (Canvas -> Video)
    // -----------------------------
    let recorder = null;
    let recordedChunks = [];
    let lastBlob = null;

    function pickMimeType() {
      const candidates = [
        "video/webm;codecs=vp8",
        "video/webm",
        "video/mp4" // iOS oft nicht, aber als letzter Versuch
      ];
      if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
      for (const t of candidates) if (MediaRecorder.isTypeSupported(t)) return t;
      return "";
    }

    function startRecording() {
      recordedChunks = [];
      lastBlob = null;
      btnShare.disabled = true;

      const fps = 15;
      const stream = canvas.captureStream(fps);

      const mimeType = pickMimeType();
      const options = mimeType ? { mimeType } : undefined;

      recorder = new MediaRecorder(stream, options);
      recorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
      recorder.onstop = () => {
        const type = (recorder && recorder.mimeType) ? recorder.mimeType : "video/webm";
        lastBlob = new Blob(recordedChunks, { type });
        btnShare.disabled = !lastBlob;
        setStatus("Aufnahme fertig.");
      };

      recorder.start(200);
      setStatus("Aufnahme läuft…");
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") recorder.stop();
    }

    async function shareOrDownload() {
      if (!lastBlob) return;

      const ext = lastBlob.type.includes("mp4") ? "mp4" : "webm";
      const fileName = `pose_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
      const file = new File([lastBlob], fileName, { type: lastBlob.type });

      // iOS Share Sheet
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: "Pose-Aufnahme" });
        setStatus("Geteilt/gespeichert.");
        return;
      }

      // Fallback: Download-Link
      const url = URL.createObjectURL(lastBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Download gestartet.");
    }

    // -----------------------------
    // MediaPipe Pose
    // -----------------------------
    let pose = null;
    let cam = null;

    function resizeCanvasToVideo() {
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      canvas.width = w;
      canvas.height = h;
    }

    function drawOutput(results) {
      // Neutraler Hintergrund (kein Kamerabild)
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!results) return;

      // 1) Silhouette (anonym) – optional
      // Hinweis: drawMask existiert, wenn drawing_utils geladen ist.
      if (toggleSilhouette.checked && results.segmentationMask && window.drawMask) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        // Wir nutzen die Maske als "Bild" + "Maske" (MediaPipe-Utility)
        // Person: weiß, Hintergrund: transparent
        window.drawMask(
          ctx,
          results.segmentationMask,
          results.segmentationMask,
          { fillColor: "white" },
          { fillColor: "transparent" }
        );
        ctx.restore();
      }

      // 2) Skelett zeichnen
      if (!results.poseLandmarks) return;
      const drawConnectorsFn = window.drawConnectors;
      const drawLandmarksFn = window.drawLandmarks;
      const connections = window.POSE_CONNECTIONS;

      if (!drawConnectorsFn || !drawLandmarksFn || !connections) return;

      ctx.save();
      // Kontrast/Lesbarkeit im Schwimmbad verbessern
      ctx.shadowBlur = 8;
      ctx.shadowColor = "black";

      drawConnectorsFn(ctx, results.poseLandmarks, connections, { lineWidth: 10 });
      drawLandmarksFn(ctx, results.poseLandmarks, { radius: 6 });

      ctx.restore();
    }

    async function initAll() {
      btnInit.disabled = true;
      setStatus("initialisiere…");

      // iPhone: Rückkamera erzwingen (exact -> fallback ideal)
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { exact: "environment" },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
      } catch (e) {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
      }

      video.srcObject = stream;
      await new Promise((res) => { video.onloadedmetadata = () => res(); });

      resizeCanvasToVideo();

      // Pose initialisieren (wichtig: new Pose(...), nicht Pose.Pose)
      pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
      });

      // Segmentation aktiv, damit Silhouette möglich ist
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: true,
        smoothSegmentation: true,
        selfieMode: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults(drawOutput);

      cam = new Camera(video, {
        onFrame: async () => { await pose.send({ image: video }); },
        width: video.videoWidth,
        height: video.videoHeight
      });

      await cam.start();

      btnRec.disabled = false;
      setStatus("bereit (Skelett läuft).");
    }

    // -----------------------------
    // UI wiring
    // -----------------------------
    btnInit.addEventListener("click", async () => {
      try {
        await initAll();
      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + (err && err.message ? err.message : String(err)));
        btnInit.disabled = false;
      }
    });

    btnRec.addEventListener("click", () => {
      btnRec.disabled = true;
      btnStop.disabled = false;
      startRecording();
    });

    btnStop.addEventListener("click", () => {
      btnStop.disabled = true;
      stopRecording();
      btnRec.disabled = false;
    });

    btnShare.addEventListener("click", () => shareOrDownload());
  </script>
</body>
</html>
