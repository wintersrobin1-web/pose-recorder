<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bewegungsanalyse Recorder (Beta) | anonym</title>
  <style>
    :root{
      --bg:#bfe7ff;
      --card:#ffffff;
      --stroke:#d9d9d9;
      --text:#111;
      --muted:#555;
    }
    *{ box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      color: var(--text);
      background: #fff;
    }

    header{
      background: var(--bg);
      padding: 16px 16px 12px;
      border-bottom: 1px solid var(--stroke);
    }
    header h1{
      margin: 0 0 6px;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    header p{
      margin: 0;
      max-width: 1050px;
      color: #1a1a1a;
      font-size: 13.5px;
      line-height: 1.35;
    }

    main{ padding: 14px 16px 22px; }

    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    .stack{ display:flex; flex-direction:column; gap:10px; }
    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 10px 12px;
    }

    .btnbar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    button{
      padding: 9px 12px;
      border-radius: 10px;
      border: 1px solid #cfcfcf;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button.primary{ border-color:#111; }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    label.toggle{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--stroke);
      border-radius: 10px;
      background:#fff;
      user-select:none;
      font-size: 13px;
    }

    select{
      padding: 9px 12px;
      border-radius: 10px;
      border: 1px solid #cfcfcf;
      background: #fff;
      font-weight:600;
      font-size: 13px;
    }

    details{
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 10px 12px;
      background:#fff;
    }
    summary{
      cursor: pointer;
      font-weight: 800;
      font-size: 13.5px;
      list-style: none;
    }
    summary::-webkit-details-marker { display:none; }

    .rangeWrap{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 8px 10px;
      border:1px solid var(--stroke);
      border-radius: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
      background:#fff;
    }
    .rangeWrap span{ min-width: 210px; font-size: 12.5px; color: var(--muted); }
    input[type="range"]{ width: 220px; }
    .small{ font-size: 12.5px; color: var(--muted); min-width: 56px; text-align:right; }

    .media{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-start;
      width: fit-content;
    }
    video, canvas{
      max-width: 100%;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      display:block;
      background: #000;
    }
    video{ width: 360px; height:auto; }
    canvas{ width: 360px; height:auto; background: var(--bg); }

    /* Tips box under canvas */
    .tipsBox{
      display:none;
      width: min(920px, 100%);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 10px 12px;
      background:#fff;
    }
    .tipsBox h3{
      margin: 0 0 6px;
      font-size: 14px;
      font-weight: 900;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
      background:#fff;
    }
    .tipsBox .hint{
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .tipsBox ul{
      margin: 6px 0 0;
      padding-left: 18px;
    }
    .tipsBox li{
      margin: 5px 0;
      font-size: 13.5px;
      line-height: 1.25;
    }

    .status{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      color: var(--muted);
      font-size: 12.5px;
      margin-top: 6px;
    }

    /* Keep recording box above canvas even in landscape */
    @media (min-width: 900px){
      .layoutWide{
        display:flex;
        gap:14px;
        align-items:flex-start;
        flex-wrap:wrap;
      }
      .media{ flex: 0 0 auto; }
      .controls{ flex: 1 1 420px; min-width: 420px; }
    }
  </style>
</head>

<body>
  <header>
    <h1>Bewegungsanalyse Recorder (Beta)</h1>
    <p>
      Beta-Version zur Aufnahme und Analyse von Skelettachsen und Bewegungen – anonym (kein identifizierbares Originalbild im Export).
      Derzeit optimiert für die Analyse der Brustschwimmen-Gleitphase.
    </p>
  </header>

  <main class="layoutWide">
    <section class="media">
      <!-- Aufnahme-Box: immer über dem Canvas (auch in Querformat) -->
      <div class="card" style="width: min(920px, 100%);">
        <div class="btnbar">
          <button id="btnInit" class="primary">Kamera aktivieren</button>
          <button id="btnSwitch" disabled>Kamera wechseln</button>
          <button id="btnRec" disabled>Aufnahme starten</button>
          <button id="btnStop" disabled>Stop</button>
          <button id="btnShare" disabled>Teilen/Speichern</button>
          <button id="btnReset" disabled>Slots zurücksetzen</button>

          <select id="filmingPreset" title="Aufnahmeposition">
            <option value="stand" selected>Stand (Test/Einweisung)</option>
            <option value="side45">45° schräg seitlich</option>
            <option value="back45">45° von hinten</option>
          </select>
        </div>

        <div class="status" id="status">Status: bereit</div>
      </div>

      <div class="row" style="margin-top:0;">
        <!-- Input-Video: standardmäßig ausgeblendet, über Anzeige (Allgemein) aktivierbar -->
        <video id="video" playsinline autoplay muted style="display:none; background:#000;"></video>
        <canvas id="canvas"></canvas>
      </div>

      <!-- Techniktipps: unter dem Canvas -->
      <div id="tipsBox" class="tipsBox">
        <h3>Techniktipps Brustschwimmen <span id="hintMeta" class="pill"></span></h3>
        <p class="hint" id="hintText"></p>
        <ul id="hintList"></ul>
      </div>
    </section>

    <section class="controls stack">
      <!-- Anzeige allgemein: standardmäßig offen (open hinzufügen/entfernen nach Wunsch) -->
      <details id="displayBox" open>
        <summary>Anzeige (allgemein)</summary>

        <div class="row" style="margin-top:10px;">
          <label class="toggle"><input type="checkbox" id="toggleSkeleton" checked /> Skelett</label>
          <label class="toggle"><input type="checkbox" id="toggleSilhouette" checked /> Anonym-Silhouette</label>
          <label class="toggle"><input type="checkbox" id="toggleVideo" /> Input-Video anzeigen (nur lokal)</label>
          <label class="toggle"><input type="checkbox" id="toggleDebug" /> Debug</label>
        </div>

        <div class="rangeWrap">
          <span>Skelett-Linienstärke</span>
          <input id="skelLine" type="range" min="1" max="10" step="1" value="3">
          <span id="skelLineVal" class="small">3</span>
        </div>

        <div class="rangeWrap">
          <span>Gelenkpunkte (Radius)</span>
          <input id="skelDot" type="range" min="1" max="10" step="1" value="4">
          <span id="skelDotVal" class="small">4</span>
        </div>

        <div class="rangeWrap">
          <span>Segmentation-Schwelle (Anonym-Silhouette)</span>
          <input id="silThresh" type="range" min="0" max="255" step="1" value="70">
          <span id="silThreshVal" class="small">70</span>
        </div>

        <div class="rangeWrap">
          <span>Silhouette-Deckkraft</span>
          <input id="silOpacity" type="range" min="0" max="1" step="0.05" value="0.40">
          <span id="silOpacityVal" class="small">0.40</span>
        </div>

        <details id="advancedBox">
          <summary>Erweiterte Einstellungen</summary>

          <div class="rangeWrap">
            <span>Detection (min)</span>
            <input id="detConf" type="range" min="0.3" max="0.95" step="0.01" value="0.50">
            <span id="detVal" class="small">0.50</span>
          </div>
          <div class="rangeWrap">
            <span>Presence (min)</span>
            <input id="presConf" type="range" min="0.3" max="0.95" step="0.01" value="0.50">
            <span id="presVal" class="small">0.50</span>
          </div>
          <div class="rangeWrap">
            <span>Tracking (min)</span>
            <input id="trackConf" type="range" min="0.3" max="0.95" step="0.01" value="0.55">
            <span id="trackVal" class="small">0.55</span>
          </div>
          <div class="rangeWrap">
            <span>Glättung (EMA)</span>
            <input id="smooth" type="range" min="0" max="0.9" step="0.05" value="0.60">
            <span id="smoothVal" class="small">0.60</span>
          </div>
          <p style="margin:10px 0 0; color:var(--muted); font-size:12.5px; line-height:1.35;">
            Hinweis: Für Schwimmen sind 0.50/0.50/0.55 häufig stabiler als sehr hohe Werte (sonst flackert/verschwindet die Pose).
          </p>
        </details>
      </details>

      <!-- Brustschwimmen-Tools: standardmäßig zu -->
      <details id="breastToolsBox">
        <summary>Brustschwimmen-Tools (spezifisch)</summary>

        <div class="row" style="margin-top:10px;">
          <label class="toggle"><input type="checkbox" id="toggleTimer" checked /> Timer: Brust-Gleiten</label>
          <label class="toggle"><input type="checkbox" id="toggleNeckAxis" checked /> HWS-Achse (Brust)</label>
          <label class="toggle"><input type="checkbox" id="toggleKneeCheck" checked /> Knie/Beine-Check (Brust)</label>
          <label class="toggle"><input type="checkbox" id="toggleHintBox" checked /> Techniktipps Brustschwimmen (nach Stop)</label>
        </div>

        <div class="rangeWrap">
          <span>HWS-Toleranz (°) – neutral vs. Überstreckung</span>
          <input id="neckTol" type="range" min="10" max="60" step="1" value="18">
          <span id="neckTolVal" class="small">18</span>
        </div>

        <div class="rangeWrap">
          <span>Knie-Schere: Toleranz (relativ)</span>
          <input id="kneeTol" type="range" min="0.05" max="0.60" step="0.01" value="0.22">
          <span id="kneeTolVal" class="small">0.22</span>
        </div>

        <details id="checklistBox">
          <summary>Häufige Technikfehler (Kurz-Checkliste)</summary>
          <p style="margin:10px 0 0; color:var(--muted); font-size:12.5px; line-height:1.35;">
            Hinweis: Dies ist nicht vollständig – hier stehen vor allem Merkmale, die sich mit einer Skelettanalyse (insb. 45° seitlich / 45° hinten) relativ gut überprüfen lassen.
          </p>
          <ul style="margin:8px 0 0; padding-left:18px; color:#222; font-size:13.5px; line-height:1.35;">
            <li><b>Arme öffnen zu weit:</b> Hände nicht weit hinter Schulterbreite „aufklappen“. Im Brustzug: aus der Streckung nach außen <u>bis etwa Schulterbreite</u>, dann Ellbogen beugen und Hände zügig vor der Brust wieder nach vorn führen.</li>
            <li><b>Schere / Asymmetrie:</b> Knie/Unterschenkel weichen deutlich auseinander oder sind zeitlich versetzt – Ziel: symmetrische Winkel und gleichzeitige Bewegung.</li>
            <li><b>Gleitphase zu kurz:</b> Nach dem Zusammenführen der Beine und vollständiger Streckung kurz stabil gleiten (grob oft <u>~0.5–1.5 s</u>, stark abhängig von Tempo/Distanz/Leistungsstand).</li>
            <li><b>Kopf überstreckt:</b> Blick zu weit nach vorn/oben – Ziel: „lang“ machen, Nacken nicht in den Nacken legen.</li>
            <li><b>Knie zu breit:</b> Knie sehr weit nach außen – häufig mehr Wasserwiderstand. Ziel: Knie moderat öffnen, Fußstellung/Rotation sauber.</li>
          </ul>
        </details>
      </details>
    </section>
  </main>

  <script type="module">
    import { FilesetResolver, PoseLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // ---------- DOM ----------
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const btnInit  = document.getElementById("btnInit");
    const btnSwitch= document.getElementById("btnSwitch");
    const btnRec   = document.getElementById("btnRec");
    const btnStop  = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const btnReset = document.getElementById("btnReset");

    const filmingPreset = document.getElementById("filmingPreset");

    const toggleSkeleton  = document.getElementById("toggleSkeleton");
    const toggleSilhouette= document.getElementById("toggleSilhouette");
    const toggleVideo     = document.getElementById("toggleVideo");
    const toggleDebug     = document.getElementById("toggleDebug");

    const skelLine = document.getElementById("skelLine");
    const skelDot  = document.getElementById("skelDot");

    const silThresh  = document.getElementById("silThresh");
    const silOpacity = document.getElementById("silOpacity");

    const detConf  = document.getElementById("detConf");
    const presConf = document.getElementById("presConf");
    const trackConf= document.getElementById("trackConf");
    const smooth   = document.getElementById("smooth");

    const toggleTimer    = document.getElementById("toggleTimer");
    const toggleNeckAxis = document.getElementById("toggleNeckAxis");
    const toggleKneeCheck= document.getElementById("toggleKneeCheck");
    const toggleHintBox  = document.getElementById("toggleHintBox");

    const neckTol = document.getElementById("neckTol");
    const kneeTol = document.getElementById("kneeTol");

    const tipsBox  = document.getElementById("tipsBox");
    const hintMeta = document.getElementById("hintMeta");
    const hintText = document.getElementById("hintText");
    const hintList = document.getElementById("hintList");

    const statusEl = document.getElementById("status");
    const setStatus = (s) => statusEl.textContent = "Status: " + s;

    // Slider readouts
    const bindSlider = (el, outId, fmt=(v)=>v) => {
      const out = document.getElementById(outId);
      const upd = () => out.textContent = fmt(el.value);
      el.addEventListener("input", upd);
      upd();
    };
    bindSlider(skelLine, "skelLineVal", v => String(Math.round(Number(v))));
    bindSlider(skelDot,  "skelDotVal",  v => String(Math.round(Number(v))));
    bindSlider(silThresh,"silThreshVal",v => String(Math.round(Number(v))));
    bindSlider(silOpacity,"silOpacityVal",v => Number(v).toFixed(2));
    bindSlider(detConf,"detVal",v => Number(v).toFixed(2));
    bindSlider(presConf,"presVal",v => Number(v).toFixed(2));
    bindSlider(trackConf,"trackVal",v => Number(v).toFixed(2));
    bindSlider(smooth,"smoothVal",v => Number(v).toFixed(2));
    bindSlider(neckTol,"neckTolVal",v => String(Math.round(Number(v))));
    bindSlider(kneeTol,"kneeTolVal",v => Number(v).toFixed(2));

    // ---------- Orientation + HiDPI ----------
    const BG = getComputedStyle(document.documentElement).getPropertyValue("--bg").trim() || "#bfe7ff";
    let CSS_W = 360, CSS_H = 640;

    function isPortraitUI(){
      const so = screen.orientation && screen.orientation.type;
      if (typeof so === "string") return so.includes("portrait");
      if (window.matchMedia) return window.matchMedia("(orientation: portrait)").matches;
      return window.innerHeight >= window.innerWidth;
    }

    const maskCanvas = document.createElement("canvas");
    const maskCtx = maskCanvas.getContext("2d", { willReadFrequently: true });

    function setupHiDPICanvas(cssW, cssH){
      CSS_W = cssW; CSS_H = cssH;
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";
      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
    }

    function applyLayoutFromOrientation(){
      // Make landscape canvas larger, portrait slightly larger too
      if (isPortraitUI()) setupHiDPICanvas(420, 720);
      else setupHiDPICanvas(760, 430);
      setStatus("Ausrichtung: " + (isPortraitUI() ? "Hochformat" : "Querformat"));
    }
    window.addEventListener("resize", applyLayoutFromOrientation);
    window.addEventListener("orientationchange", applyLayoutFromOrientation);

    // ---------- Pose connections (remove fingertip-to-fingertip connector) ----------
    // We keep wrist->thumb/index/pinky rays but remove pinky<->index cross link.
    const POSE_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,7],
      [0,4],[4,5],[5,6],[6,8],
      [9,10],
      [11,12],
      [11,13],[13,15],
      [15,17],[15,19],[15,21], // left wrist rays
      // removed [17,19]
      [12,14],[14,16],
      [16,18],[16,20],[16,22], // right wrist rays
      // removed [18,20]
      [11,23],[12,24],[23,24],
      [23,25],[25,27],[27,29],[29,31],
      [24,26],[26,28],[28,30],[30,32],
      [27,28]
    ];

    // ---------- Video->Canvas mapping ("contain") in CSS space ----------
    function mapLandmarksContain(raw, vw, vh, cw, ch){
      const scale = Math.min(cw / vw, ch / vh);
      const dispW = vw * scale, dispH = vh * scale;
      const offX = (cw - dispW) / 2;
      const offY = (ch - dispH) / 2;

      return raw.map(p => {
        const px = p.x * vw;
        const py = p.y * vh;
        return { ...p, _cx: offX + px * scale, _cy: offY + py * scale };
      });
    }

    // ---------- Segmentation mask (anonym silhouette) ----------
    function segMaskToCanvas(segMask){
      if (!segMask) return null;
      if (typeof segMask.getAsCanvas === "function") return segMask.getAsCanvas();
      if (segMask.canvas) return segMask.canvas;
      return null;
    }

    function drawMaskContainIntoMaskCanvas(sc, vw, vh){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cw = CSS_W, ch = CSS_H;

      const scale = Math.min(cw / vw, ch / vh);
      const dispW = vw * scale, dispH = vh * scale;
      const offX = (cw - dispW) / 2;
      const offY = (ch - dispH) / 2;

      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      maskCtx.drawImage(
        sc,
        0, 0, sc.width, sc.height,
        Math.round(offX * dpr), Math.round(offY * dpr),
        Math.round(dispW * dpr), Math.round(dispH * dpr)
      );
    }

    function drawAnonymSilhouette(segMask){
      if (!toggleSilhouette.checked || !segMask) return { maskMax: 0 };

      const sc = segMaskToCanvas(segMask);
      if (!sc) return { maskMax: 0 };

      const vw = video.videoWidth || 0, vh = video.videoHeight || 0;
      if (!vw || !vh) return { maskMax: 0 };

      drawMaskContainIntoMaskCanvas(sc, vw, vh);

      const img = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
      const d = img.data;

      const thresh = Math.max(0, Math.min(255, Math.round(Number(silThresh.value))));
      const opacity = Math.max(0, Math.min(1, Number(silOpacity.value)));
      const alphaBase = Math.round(255 * opacity);

      let maskMax = 0;

      // Yellow silhouette over uniform background (no original image visible in export)
      for (let i = 0; i < d.length; i += 4) {
        const m = Math.max(d[i], d[i+1], d[i+2], d[i+3]); // robust intensity
        if (m > maskMax) maskMax = m;

        if (m >= thresh) {
          d[i]   = 255; // R
          d[i+1] = 210; // G
          d[i+2] = 0;   // B
          d[i+3] = Math.min(255, Math.round((m / 255) * alphaBase) + 35);
        } else {
          d[i+3] = 0;
        }
      }
      maskCtx.putImageData(img, 0, 0);

      ctx.drawImage(maskCanvas, 0, 0, CSS_W, CSS_H);
      return { maskMax };
    }

    // ---------- EMA smoothing in CSS space ----------
    let smoothedCss = null;
    function emaCss(cssPoints){
      const a = Number(smooth.value);
      if (!cssPoints) return null;

      if (!smoothedCss || smoothedCss.length !== cssPoints.length){
        smoothedCss = cssPoints.map(p => ({ ...p }));
        return smoothedCss;
      }
      for (let i = 0; i < cssPoints.length; i++){
        const p = cssPoints[i], s = smoothedCss[i];
        s._cx = a * s._cx + (1 - a) * p._cx;
        s._cy = a * s._cy + (1 - a) * p._cy;
        s.z = a * (s.z ?? 0) + (1 - a) * (p.z ?? 0);
        if (typeof p.visibility === "number") s.visibility = p.visibility;
        if (typeof p.presence === "number") s.presence = p.presence;
      }
      return smoothedCss;
    }

    // ---------- Drawing skeleton ----------
    function drawSkeleton(cssPoints){
      if (!toggleSkeleton.checked || !cssPoints) return;

      const lw = Math.round(Number(skelLine.value));
      const r  = Math.round(Number(skelDot.value));

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "#000";
      ctx.fillStyle = "#000";
      ctx.lineWidth = lw;

      for (const [a,b] of POSE_CONNECTIONS){
        const pa = cssPoints[a], pb = cssPoints[b];
        if (!pa || !pb) continue;

        // skip low visibility points
        if (typeof pa.visibility === "number" && pa.visibility < 0.2) continue;
        if (typeof pb.visibility === "number" && pb.visibility < 0.2) continue;

        ctx.beginPath();
        ctx.moveTo(pa._cx, pa._cy);
        ctx.lineTo(pb._cx, pb._cy);
        ctx.stroke();
      }

      for (const p of cssPoints){
        if (!p) continue;
        if (typeof p.visibility === "number" && p.visibility < 0.2) continue;
        ctx.beginPath();
        ctx.arc(p._cx, p._cy, r, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }

    // ---------- Brust: Timer / Slots ----------
    const glideTimes = [];
    let glideActive=false, glideStart=0, currentElapsed=0;
    let poseStableSince=null, poseLostSince=null;

    const dist = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    const fmt  = (ms)=> (ms/1000).toFixed(3) + " s";

    // More permissive "streamline" for side view: allow one-arm overhead + straight legs
    function isStreamlineSide(raw){
      const ls=raw[11], rs=raw[12], lh=raw[23], rh=raw[24];
      const le=raw[13], re=raw[14], lw=raw[15], rw=raw[16];
      const lk=raw[25], rk=raw[26], la=raw[27], ra=raw[28];
      if(!ls||!rs||!lh||!rh||!lk||!rk||!la||!ra) return false;

      // body elongated (shoulder-hip distance)
      const sh = {x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2};
      const hp = {x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2};
      if (dist(sh,hp) < 0.10) return false;

      // legs "not bent": knee angle near 180 (rough)
      const kneeAngle = (hip,knee,ank)=>{
        const ux = hip.x-knee.x, uy=hip.y-knee.y;
        const vx = ank.x-knee.x, vy=ank.y-knee.y;
        const du = Math.hypot(ux,uy), dv=Math.hypot(vx,vy);
        if(!du||!dv) return 0;
        const cos = (ux*vx+uy*vy)/(du*dv);
        return Math.acos(Math.max(-1,Math.min(1,cos))) * 180/Math.PI;
      };
      const aL = kneeAngle(lh,lk,la);
      const aR = kneeAngle(rh,rk,ra);
      const legsStraight = (aL>150 && aR>150);

      // arms overhead: either left OR right sufficiently extended upward relative to shoulders
      let leftOver=false, rightOver=false;
      if(le && lw){
        leftOver = (lw.y < ls.y - 0.03) && dist(ls,lw) > 0.22;
      }
      if(re && rw){
        rightOver = (rw.y < rs.y - 0.03) && dist(rs,rw) > 0.22;
      }

      return legsStraight && (leftOver || rightOver);
    }

    function isStandOverhead(raw){
      const ls=raw[11], rs=raw[12], lw=raw[15], rw=raw[16], le=raw[13], re=raw[14];
      if(!ls||!rs||!lw||!rw||!le||!re) return false;
      const shoulderY=(ls.y+rs.y)/2;
      const wristsUp=(lw.y<shoulderY-0.03)||(rw.y<shoulderY-0.03); // allow one arm
      const elbowsOk=(le.y<shoulderY+0.05)||(re.y<shoulderY+0.05);
      return wristsUp && elbowsOk;
    }

    function inGlidePose(raw){
      const p = filmingPreset.value;
      if (p==="stand")  return isStandOverhead(raw);
      if (p==="side45") return isStreamlineSide(raw);
      // back45 keeps your previous robust criteria but allow one arm
      const ls=raw[11], rs=raw[12], lw=raw[15], rw=raw[16], lh=raw[23], rh=raw[24];
      if(!ls||!rs||!lh||!rh) return false;
      const sh={x:(ls.x+rs.x)/2,y:(ls.y+rs.y)/2};
      const hp={x:(lh.x+rh.x)/2,y:(lh.y+rh.y)/2};
      if(dist(sh,hp)<0.10) return false;

      let leftExt=false, rightExt=false;
      if(ls&&lw) leftExt = dist(ls,lw) > 0.23;
      if(rs&&rw) rightExt= dist(rs,rw) > 0.23;
      return (leftExt || rightExt);
    }

    function updateTimer(raw, now){
      if(!toggleTimer.checked){
        glideActive=false; poseStableSince=null; poseLostSince=null; currentElapsed=0;
        return;
      }

      // Make start faster and stop responsive for side45
      const p = filmingPreset.value;
      const startHold = (p==="side45") ? 220 : (p==="stand" ? 180 : 320);
      const stopHold  = (p==="side45") ? 260 : (p==="stand" ? 160 : 380);

      const ok = inGlidePose(raw);

      if(!glideActive){
        currentElapsed=0;
        if(ok && glideTimes.length<4){
          if(poseStableSince===null) poseStableSince=now;
          if(now - poseStableSince >= startHold){
            glideActive=true; glideStart=now; poseLostSince=null;
          }
        } else {
          poseStableSince=null;
        }
        return;
      }

      currentElapsed = now - glideStart;

      if(!ok){
        if(poseLostSince===null) poseLostSince=now;
        if(now - poseLostSince >= stopHold){
          glideActive=false; poseStableSince=null; poseLostSince=null;
          glideTimes.push(now - glideStart);
          if(glideTimes.length>4) glideTimes.length=4;
          currentElapsed=0;
        }
      } else {
        poseLostSince=null;
      }
    }

    // ---------- Overlay (timer box + slots layout responsive) ----------
    function drawOverlay(debugLine=""){
      if(!toggleTimer.checked && !toggleDebug.checked) return;

      const showTimer = toggleTimer.checked;

      // Box dimensions: in landscape be more wide and less tall
      const pad = 12;
      const x = 12, y = 12;
      const w = Math.min(CSS_W - 24, isPortraitUI() ? 520 : 720);
      const h = showTimer ? (isPortraitUI() ? 155 : 115) : 45;

      // background box
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.42)";
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 2;

      const r = 14;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "white";
      ctx.shadowBlur = 0;

      if (showTimer){
        // time
        ctx.font = isPortraitUI() ? "800 32px system-ui" : "800 28px system-ui";
        ctx.fillText(glideActive ? fmt(currentElapsed) : "0.000 s", x+pad, y+(isPortraitUI()?42:36));

        // label
        ctx.font = "700 12.5px system-ui";
        const presetLabel = filmingPreset.value==="stand" ? "Stand" : (filmingPreset.value==="side45" ? "45° seitlich" : "45° hinten");
        ctx.fillText(`Timer Brust-Gleiten | Aufnahme: ${presetLabel}`, x+pad, y+(isPortraitUI()?64:56));

        // slots: portrait vertical list, landscape one line
        ctx.font = "600 14px system-ui";
        if (isPortraitUI()){
          for(let i=0;i<4;i++){
            const t = glideTimes[i]!=null ? fmt(glideTimes[i]) : "—";
            ctx.fillText(`Slot ${i+1}: ${t}`, x+pad, y+86+i*16);
          }
        } else {
          // one line with 4 items
          const baseY = y+84;
          const parts = [];
          for(let i=0;i<4;i++){
            const t = glideTimes[i]!=null ? fmt(glideTimes[i]) : "—";
            parts.push(`S${i+1}: ${t}`);
          }
          ctx.fillText(parts.join("   "), x+pad, baseY);
        }
      }

      if (toggleDebug.checked && debugLine){
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
        ctx.fillText(debugLine, x+pad, y+h-10);
      }

      ctx.restore();
    }

    // ---------- Brust: HWS axis + knee check ----------
    // Landmark indices (MediaPipe Pose)
    // 0 nose, 7 left ear, 8 right ear, 11/12 shoulders, 23/24 hips, 25/26 knees, 27/28 ankles
    const v2 = (a,b)=>({x:b.x-a.x,y:b.y-a.y});
    const norm2 = (v)=>{ const d=Math.hypot(v.x,v.y); return d?{x:v.x/d,y:v.y/d}:{x:0,y:0}; };
    const dot2 = (u,v)=>u.x*v.x+u.y*v.y;
    const angleBetween = (u,v)=>{
      const c = Math.max(-1, Math.min(1, dot2(u,v)));
      return Math.acos(c) * 180/Math.PI;
    };

    function detectSideView(raw){
      const ls = raw[11], rs = raw[12];
      if(!ls||!rs) return false;
      // If shoulders are close in x, body is likely rotated/side
      return Math.abs(ls.x - rs.x) < 0.12;
    }

    function drawNeckAxis(cssPoints, raw){
      if(!toggleNeckAxis.checked || !cssPoints || !raw) return;

      const ls=raw[11], rs=raw[12], lh=raw[23], rh=raw[24];
      if(!ls||!rs||!lh||!rh) return;

      // neck base (mid shoulders)
      const neckBase = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };

      // head point: prefer midpoint of ears (more stable than nose for side view); fallback nose.
      const le = raw[7], re = raw[8], nose = raw[0];
      let headPoint = null;
      if (le && re) headPoint = { x:(le.x+re.x)/2, y:(le.y+re.y)/2 };
      else if (nose) headPoint = { x:nose.x, y:nose.y };
      else return;

      // torso direction: hip mid -> shoulder mid
      const torsoBase = { x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2 };
      const torsoTop  = neckBase;

      const torsoN = norm2(v2(torsoBase, torsoTop));
      const neckN  = norm2(v2(neckBase, headPoint));
      const deg = angleBetween(torsoN, neckN);

      // Decide which logic to apply:
      // - If preset side45 OR the body appears side-on (also in stand), use side logic:
      //   "too small" angle = overextension => red; ">= tol" => green.
      // - Otherwise: "too large" deviation from torso = bad => red; "<= tol" => green.
      const tol = Number(neckTol.value);
      const sideLogic = (filmingPreset.value === "side45") || detectSideView(raw);

      let ok;
      if (sideLogic){
        ok = deg >= tol;
      } else {
        ok = deg <= tol;
      }

      // Draw line in CSS space using mapped points (we need matching points for neckBase and headPoint)
      // We'll approximate by using mapped canvas coords from corresponding landmarks:
      const neckBasePx = {
        x: (cssPoints[11]._cx + cssPoints[12]._cx)/2,
        y: (cssPoints[11]._cy + cssPoints[12]._cy)/2
      };

      // head px from ears mid (prefer) else nose
      let headPx = null;
      if (cssPoints[7] && cssPoints[8]){
        headPx = { x:(cssPoints[7]._cx + cssPoints[8]._cx)/2, y:(cssPoints[7]._cy + cssPoints[8]._cy)/2 };
      } else if (cssPoints[0]){
        headPx = { x: cssPoints[0]._cx, y: cssPoints[0]._cy };
      } else {
        return;
      }

      ctx.save();
      ctx.lineCap="round";
      ctx.lineJoin="round";
      ctx.lineWidth = 4;
      ctx.strokeStyle = ok ? "rgba(0,160,0,0.95)" : "rgba(220,0,0,0.95)";
      ctx.beginPath();
      ctx.moveTo(neckBasePx.x, neckBasePx.y);
      ctx.lineTo(headPx.x, headPx.y);
      ctx.stroke();
      ctx.restore();
    }

    function drawKneeWidthIndicator(cssPoints, raw){
      if(!toggleKneeCheck.checked || !cssPoints || !raw) return;

      const lk = raw[25], rk = raw[26], ls=raw[11], rs=raw[12];
      if(!lk||!rk||!ls||!rs) return;

      const kneeW = Math.abs(lk.x - rk.x);
      const shW   = Math.abs(ls.x - rs.x) || 1e-6;
      const ratio = kneeW / shW;

      const tol = Number(kneeTol.value);
      const ok = ratio <= tol;

      // Draw thin measurement line between knees (not a skeleton connection)
      const a = cssPoints[25], b = cssPoints[26];
      if(!a||!b) return;

      ctx.save();
      ctx.lineWidth = 2;                 // thinner so it reads as "measurement"
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = ok ? "rgba(0,160,0,0.9)" : "rgba(220,0,0,0.9)";
      ctx.beginPath();
      ctx.moveTo(a._cx, a._cy);
      ctx.lineTo(b._cx, b._cy);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();

      // Do NOT print label in canvas (user asked)
    }

    // ---------- Session stats for tips (recording window only) ----------
    let recordingActive = false;
    let session = null;

    function resetSession(){
      session = {
        frames: 0,
        neckBad: 0,
        kneeBad: 0,
        glideCounted: 0, // how many frames in valid glide
        // for stable decisions:
        kneeBadStreakMax: 0,
        neckBadStreakMax: 0,
        _kneeStreak: 0,
        _neckStreak: 0
      };
    }

    function updateSessionStats(raw, neckOk, kneeOk, glideOk){
      if(!recordingActive || !session) return;
      session.frames++;

      if (toggleNeckAxis.checked){
        if(!neckOk){
          session.neckBad++;
          session._neckStreak++;
          session.neckBadStreakMax = Math.max(session.neckBadStreakMax, session._neckStreak);
        } else {
          session._neckStreak = 0;
        }
      }

      if (toggleKneeCheck.checked){
        if(!kneeOk){
          session.kneeBad++;
          session._kneeStreak++;
          session.kneeBadStreakMax = Math.max(session.kneeBadStreakMax, session._kneeStreak);
        } else {
          session._kneeStreak = 0;
        }
      }

      if (toggleTimer.checked){
        if (glideOk) session.glideCounted++;
      }
    }

    function hideTips(){
      tipsBox.style.display = "none";
      hintMeta.textContent = "";
      hintText.textContent = "";
      hintList.innerHTML = "";
    }

    function showTipsFromSession(){
      if(!toggleHintBox.checked || !session || session.frames < 10){
        hideTips();
        return;
      }

      // Select up to 3 strongest issues based on rate + streak
      const issues = [];

      const neckRate = session.frames ? session.neckBad / session.frames : 0;
      const kneeRate = session.frames ? session.kneeBad / session.frames : 0;

      if (toggleNeckAxis.checked && (neckRate > 0.18 || session.neckBadStreakMax >= 18)){
        issues.push({
          key: "neck",
          score: neckRate + (session.neckBadStreakMax/120),
          text: "<b>Kopf/Nacken:</b> häufige Überstreckung erkannt. Tipp: Blick eher nach unten/vorn, Nacken „lang“ lassen – nicht in den Nacken legen."
        });
      }
      if (toggleKneeCheck.checked && (kneeRate > 0.18 || session.kneeBadStreakMax >= 18)){
        issues.push({
          key: "knee",
          score: kneeRate + (session.kneeBadStreakMax/120),
          text: "<b>Schere/Kniebreite:</b> Asymmetrie oder sehr breite Knie erkannt. Tipp: Knie moderat öffnen, Bewegung beidseitig synchron; Füße sauber ausdrehen."
        });
      }

      // Glide too short: if timer exists but almost no glide frames
      if (toggleTimer.checked){
        const glideRate = session.frames ? session.glideCounted / session.frames : 0;
        if (glideRate < 0.10){
          issues.push({
            key: "glide",
            score: 0.35,
            text: "<b>Gleitphase:</b> wenig stabile Streck-/Gleitmomente erkannt. Tipp: nach dem Beinschluss bewusst kurz stabil gleiten (ca. 0.5–1.5 s, je nach Tempo)."
          });
        }
      }

      issues.sort((a,b)=>b.score-a.score);
      const top = issues.slice(0,3);

      if (!top.length){
        hideTips();
        return;
      }

      hintMeta.textContent = `letzte Sequenz · ${session.frames} Frames`;
      hintText.textContent = "Automatisch generierte Hinweise (Beta). Nutze sie als Orientierung – keine Trainerdiagnose.";
      hintList.innerHTML = top.map(x=>`<li>${x.text}</li>`).join("");
      tipsBox.style.display = "block";
    }

    // ---------- MediaPipe Tasks ----------
    let landmarker = null;
    let running = false;
    let rafId = null;

    const POSE_TASK_URL =
      "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task";

    async function createLandmarker(){
      setStatus("Lade Tasks-WASM …");
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
      );

      setStatus("Lade Pose Landmarker heavy …");
      landmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: POSE_TASK_URL },
        runningMode: "VIDEO",
        numPoses: 1,
        outputSegmentationMasks: true,
        minPoseDetectionConfidence: Number(detConf.value),
        minPosePresenceConfidence: Number(presConf.value),
        minTrackingConfidence: Number(trackConf.value),
      });
    }

    function updateLandmarkerThresholds(){
      if(!landmarker) return;
      landmarker.setOptions({
        minPoseDetectionConfidence: Number(detConf.value),
        minPosePresenceConfidence: Number(presConf.value),
        minTrackingConfidence: Number(trackConf.value),
      });
      setStatus("Schwellwerte aktualisiert.");
    }
    detConf.addEventListener("change", updateLandmarkerThresholds);
    presConf.addEventListener("change", updateLandmarkerThresholds);
    trackConf.addEventListener("change", updateLandmarkerThresholds);

    // ---------- Camera ----------
    let isBackCamera = true;
    let stream = null;

    async function startCamera(){
      stopCamera();
      stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{
          facingMode: isBackCamera ? "environment" : "user",
          width:{ideal:1280},
          height:{ideal:720}
        }
      });
      video.srcObject = stream;

      await new Promise((resolve)=>{
        const done=()=>resolve();
        if(video.readyState>=1) return done();
        video.onloadedmetadata = done;
      });
      await video.play();

      await new Promise((resolve)=>{
        const check=()=> (video.videoWidth>0 && video.videoHeight>0) ? resolve() : requestAnimationFrame(check);
        check();
      });
    }

    function stopCamera(){
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      video.srcObject=null;
    }

    // Toggle input video visibility
    toggleVideo.addEventListener("change", ()=>{
      video.style.display = toggleVideo.checked ? "block" : "none";
    });

    // ---------- Recording (canvas stream) ----------
    let recorder=null, recordedChunks=[], lastBlob=null;

    function pickMimeType(){
      const candidates=[
        'video/mp4;codecs="avc1.42E01E"',
        'video/mp4;codecs="avc1.4D401E"',
        "video/mp4",
        'video/webm;codecs="vp8"',
        "video/webm"
      ];
      if(!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
      for(const t of candidates){ try{ if(MediaRecorder.isTypeSupported(t)) return t; } catch(_){} }
      return "";
    }

    function startRecordingCanvas(){
      recordedChunks=[]; lastBlob=null; btnShare.disabled=true;

      // hide last tips for new take
      hideTips();
      resetSession();
      recordingActive = true;

      const s = canvas.captureStream(15);
      const mt = pickMimeType();
      try{ recorder=new MediaRecorder(s, mt?{mimeType:mt}:undefined); }
      catch(_){ recorder=new MediaRecorder(s); }

      setStatus("Aufnahme läuft… (" + (recorder.mimeType || mt || "default") + ")");
      recorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
      recorder.onstop=()=>{
        recordingActive = false;
        const type = recorder.mimeType || mt || "video/webm";
        lastBlob = new Blob(recordedChunks,{type});
        btnShare.disabled = !lastBlob;

        // show tips for last take
        showTipsFromSession();

        setStatus("Aufnahme fertig (" + (lastBlob.type.includes("mp4") ? "MP4" : "WebM") + ").");
      };
      recorder.start(200);
    }

    function stopRecordingCanvas(){ if(recorder && recorder.state!=="inactive") recorder.stop(); }

    async function shareOrDownload(){
      if(!lastBlob) return;
      const type=lastBlob.type||"";
      const ext=type.includes("mp4")?"mp4":(type.includes("webm")?"webm":"bin");
      const fileName=`bewegungsanalyse_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
      const file=new File([lastBlob],fileName,{type:lastBlob.type});

      if(navigator.canShare && navigator.canShare({files:[file]})){
        await navigator.share({files:[file], title:"Bewegungsanalyse Recorder (anonym)"});
        setStatus("Geteilt/gespeichert ("+ext.toUpperCase()+").");
        return;
      }
      const url=URL.createObjectURL(lastBlob);
      const a=document.createElement("a");
      a.href=url; a.download=fileName;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),2000);
      setStatus("Download gestartet ("+ext.toUpperCase()+").");
    }

    // ---------- Loop ----------
    function loop(){
      if(!running || !landmarker) return;

      try{
        // background
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, CSS_W, CSS_H);

        if(video.videoWidth===0 || video.videoHeight===0){
          drawOverlay("DEBUG: video not ready");
          rafId = requestAnimationFrame(loop);
          return;
        }

        const ts = performance.now();
        const result = landmarker.detectForVideo(video, ts);

        const hasMask = !!(result?.segmentationMasks?.length);
        const hasLandmarks = !!(result?.landmarks?.length && result.landmarks[0]?.length);

        // Optional local-only video preview (NOT in exported rendering; we only draw it on canvas if you want)
        // For anonymity, we do NOT draw the raw video into the canvas output.
        // (toggleVideo only shows the separate <video> element)

        // silhouette
        let maskMax = 0;
        if(hasMask){
          const m = drawAnonymSilhouette(result.segmentationMasks[0]);
          maskMax = m.maskMax || 0;
        }

        let debugLine = "";
        let neckOk = true, kneeOk = true, glideOk = false;

        if(hasLandmarks){
          const raw = result.landmarks[0];

          // map to CSS
          const cssPoints = emaCss(mapLandmarksContain(raw, video.videoWidth, video.videoHeight, CSS_W, CSS_H));

          // skeleton
          drawSkeleton(cssPoints);

          // timer logic
          glideOk = inGlidePose(raw);
          updateTimer(raw, ts);

          // neck evaluation (compute ok to store stats)
          if (toggleNeckAxis.checked){
            const ls=raw[11], rs=raw[12], lh=raw[23], rh=raw[24];
            const le=raw[7], re=raw[8], nose=raw[0];
            if(ls&&rs&&lh&&rh&&( (le&&re) || nose )){
              const neckBase = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };
              const headPoint = (le&&re) ? { x:(le.x+re.x)/2, y:(le.y+re.y)/2 } : { x:nose.x, y:nose.y };
              const torsoBase = { x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2 };
              const torsoN = norm2(v2(torsoBase, neckBase));
              const neckN  = norm2(v2(neckBase, headPoint));
              const deg = angleBetween(torsoN, neckN);
              const tol = Number(neckTol.value);
              const sideLogic = (filmingPreset.value === "side45") || detectSideView(raw);

              neckOk = sideLogic ? (deg >= tol) : (deg <= tol);
              drawNeckAxis(cssPoints, raw);
            }
          }

          // knee check ok?
          if (toggleKneeCheck.checked){
            const lk = raw[25], rk = raw[26], ls=raw[11], rs=raw[12];
            if(lk&&rk&&ls&&rs){
              const kneeW = Math.abs(lk.x - rk.x);
              const shW   = Math.abs(ls.x - rs.x) || 1e-6;
              const ratio = kneeW / shW;
              kneeOk = ratio <= Number(kneeTol.value);
              drawKneeWidthIndicator(cssPoints, raw);
            }
          }

          // update stats (only while recording)
          updateSessionStats(raw, neckOk, kneeOk, glideOk);

          if (toggleDebug.checked){
            debugLine = `DEBUG: lm=${raw.length} mask=${hasMask?1:0} maskmax=${maskMax} ui=${isPortraitUI()?"P":"L"} v=${video.videoWidth}x${video.videoHeight} c=${CSS_W}x${CSS_H}`;
          }
        } else {
          if (toggleDebug.checked){
            debugLine = `DEBUG: lm=0 mask=${hasMask?1:0} maskmax=${maskMax} ui=${isPortraitUI()?"P":"L"} v=${video.videoWidth}x${video.videoHeight} c=${CSS_W}x${CSS_H}`;
          }
        }

        drawOverlay(debugLine);
        rafId = requestAnimationFrame(loop);
      } catch(e){
        console.error(e);
        setStatus("Loop-Fehler: " + (e?.message || String(e)));
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, CSS_W, CSS_H);
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.font = "16px system-ui";
        ctx.fillText("Loop-Fehler: " + (e?.message || String(e)), 20, 40);
      }
    }

    // ---------- Buttons ----------
    btnInit.addEventListener("click", async ()=>{
      try{
        btnInit.disabled=true;

        applyLayoutFromOrientation();
        setStatus("Initialisiere …");
        await createLandmarker();
        await startCamera();

        running=true;
        btnSwitch.disabled=false;
        btnRec.disabled=false;
        btnReset.disabled=false;

        hideTips();
        setStatus("bereit.");
        rafId = requestAnimationFrame(loop);
      } catch(e){
        console.error(e);
        setStatus("Fehler: " + (e?.message || String(e)));
        btnInit.disabled=false;
      }
    });

    btnSwitch.addEventListener("click", async ()=>{
      try{
        btnSwitch.disabled=true;

        running=false;
        if(rafId) cancelAnimationFrame(rafId);

        isBackCamera=!isBackCamera;
        await startCamera();

        // reset smoothing + timer holds so nothing sticks
        smoothedCss = null;
        poseStableSince = null;
        poseLostSince = null;

        running=true;
        rafId = requestAnimationFrame(loop);

        btnSwitch.disabled=false;
        setStatus("Kamera gewechselt.");
      } catch(e){
        console.error(e);
        setStatus("Kamerawechsel-Fehler: " + (e?.message || String(e)));
        running=true;
        rafId = requestAnimationFrame(loop);
        btnSwitch.disabled=false;
      }
    });

    btnRec.addEventListener("click", ()=>{
      btnRec.disabled=true;
      btnStop.disabled=false;
      startRecordingCanvas();
    });

    btnStop.addEventListener("click", ()=>{
      btnStop.disabled=true;
      stopRecordingCanvas();
      btnRec.disabled=false;
    });

    btnShare.addEventListener("click", ()=>shareOrDownload());

    btnReset.addEventListener("click", ()=>{
      glideTimes.length=0;
      glideActive=false; poseStableSince=null; poseLostSince=null; currentElapsed=0;
      setStatus("Slots zurückgesetzt.");
    });

    // Initial layout
    applyLayoutFromOrientation();
  </script>
</body>
</html>
