<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pose Recorder (Skelett)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    video, canvas { max-width: 100%; width: 480px; height: auto; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; background: #fff; }
    button.primary { border-color: #111; }
    .hint { color: #555; font-size: 14px; line-height: 1.4; }
  </style>

  <!-- MediaPipe (klassisch, ohne ES-Module) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
</head>

<body>
  <h1>Pose Recorder (nur Skelett-Video)</h1>
  <p class="hint">
    Speichert nur die abstrakte Skelettdarstellung (Canvas), nicht das Kamerabild.
    Bitte per HTTPS (GitHub Pages) nutzen.
  </p>

  <div class="row">
    <button id="btnInit" class="primary">Kamera aktivieren</button>
    <button id="btnRec" disabled>Aufnahme starten</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnShare" disabled>Teilen/Speichern</button>
  </div>

  <div class="row">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <p class="hint" id="status">Status: bereit</p>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const btnInit = document.getElementById("btnInit");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const btnShare = document.getElementById("btnShare");
    const statusEl = document.getElementById("status");

    function setStatus(s) { statusEl.textContent = "Status: " + s; }

    // Aufnahme (Canvas -> Video)
    let recorder = null;
    let recordedChunks = [];
    let lastBlob = null;

    function pickMimeType() {
      // iOS/Safari ist wählerisch; wir nehmen, was unterstützt wird.
      const candidates = [
        "video/webm;codecs=vp8",
        "video/webm",
        "video/mp4" // oft NICHT unterstützt; nur als Fallback
      ];
      if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return "";
      for (const t of candidates) {
        if (MediaRecorder.isTypeSupported(t)) return t;
      }
      return "";
    }

    function startRecording() {
      recordedChunks = [];
      lastBlob = null;
      btnShare.disabled = true;

      const fps = 15;
      const stream = canvas.captureStream(fps);

      const mimeType = pickMimeType();
      const options = mimeType ? { mimeType } : undefined;

      recorder = new MediaRecorder(stream, options);
      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const type = (recorder && recorder.mimeType) ? recorder.mimeType : "video/webm";
        lastBlob = new Blob(recordedChunks, { type });
        btnShare.disabled = !lastBlob;
        setStatus("Aufnahme fertig.");
      };

      recorder.start(200);
      setStatus("Aufnahme läuft…");
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") recorder.stop();
    }

    async function shareOrDownload() {
      if (!lastBlob) return;

      const ext = lastBlob.type.includes("mp4") ? "mp4" : "webm";
      const fileName = `pose_${new Date().toISOString().replace(/[:.]/g,"-")}.${ext}`;
      const file = new File([lastBlob], fileName, { type: lastBlob.type });

      // iOS: Share Sheet ist meist der beste Weg
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: "Pose-Aufnahme" });
        setStatus("Geteilt/gespeichert.");
        return;
      }

      // Fallback: Download-Link
      const url = URL.createObjectURL(lastBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Download gestartet.");
    }

    // MediaPipe Pose Setup
    let pose = null;
    let cam = null;

    function resizeCanvasToVideo() {
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      canvas.width = w;
      canvas.height = h;
    }

    function drawSkeleton(results) {
      // KEIN Kamerabild rendern -> neutraler Hintergrund
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!results.poseLandmarks) return;

      // Skelett zeichnen
      // (Zeichnet Verbindungen + Punkte; keine Person erkennbar)
      drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, { lineWidth: 4 });
      drawLandmarks(ctx, results.poseLandmarks, { radius: 3 });
    }

    async function initAll() {
      btnInit.disabled = true;
      setStatus("initialisiere…");

      // iPhone: Kamera via getUserMedia; MediaPipe Camera steuert Frames an Pose
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "environment",
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });

      video.srcObject = stream;
      await new Promise((res) => { video.onloadedmetadata = () => res(); });
      resizeCanvasToVideo();

      pose = new Pose({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
});

      // Modell-Komplexität reduzieren -> stabiler auf iPhone
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        selfieMode: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults(drawSkeleton);

      cam = new Camera(video, {
        onFrame: async () => {
          await pose.send({ image: video });
        },
        width: video.videoWidth,
        height: video.videoHeight
      });

      await cam.start();

      btnRec.disabled = false;
      setStatus("bereit (Skelett läuft).");
    }

    btnInit.addEventListener("click", async () => {
      try {
        await initAll();
      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + (err && err.message ? err.message : String(err)));
        btnInit.disabled = false;
      }
    });

    btnRec.addEventListener("click", () => {
      btnRec.disabled = true;
      btnStop.disabled = false;
      startRecording();
    });

    btnStop.addEventListener("click", () => {
      btnStop.disabled = true;
      stopRecording();
      btnRec.disabled = false;
    });

    btnShare.addEventListener("click", () => shareOrDownload());
  </script>
</body>
</html>
