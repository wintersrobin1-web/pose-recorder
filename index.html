<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Pose Recorder – FINAL STABIL</title>

<style>
body {
  font-family: system-ui, sans-serif;
  margin: 16px;
}
.row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 12px;
}
video, canvas {
  width: 360px;
  max-width: 100%;
  border-radius: 12px;
  border: 1px solid #ccc;
}
button {
  padding: 10px 14px;
  border-radius: 10px;
}
label {
  display: inline-flex;
  gap: 6px;
  align-items: center;
}
</style>
</head>

<body>

<h2>Pose Recorder – finale Version</h2>

<div class="row">
  <button id="btnInit">Kamera starten</button>
  <button id="btnSwitch" disabled>Kamera wechseln</button>
</div>

<div class="row">
  <label><input type="checkbox" id="chkSkeleton" checked>Skelett</label>
  <label><input type="checkbox" id="chkMask" checked>Silhouette</label>
</div>

<div class="row">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>
</div>

<p id="status">bereit</p>

<script type="module">
import {
  FilesetResolver,
  PoseLandmarker,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

// ---------------- DOM ----------------
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const btnInit = document.getElementById("btnInit");
const btnSwitch = document.getElementById("btnSwitch");
const chkSkeleton = document.getElementById("chkSkeleton");
const chkMask = document.getElementById("chkMask");
const statusEl = document.getElementById("status");

// ---------------- State ----------------
let landmarker = null;
let drawingUtils = null;
let stream = null;
let running = false;
let isBackCamera = true;
let rafId = null;

// ---------------- Helpers ----------------
function setStatus(t) {
  statusEl.textContent = t;
}

// Canvas = Videoauflösung (KEIN DPR, KEIN Transform)
function syncCanvasToVideo() {
  canvas.width  = video.videoWidth;
  canvas.height = video.videoHeight;
}

// ---------------- MediaPipe ----------------
async function createLandmarker() {
  const fileset = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
  );

  landmarker = await PoseLandmarker.createFromOptions(fileset, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task"
    },
    runningMode: "VIDEO",
    numPoses: 1,
    outputSegmentationMasks: true
  });

  drawingUtils = new DrawingUtils(ctx);
}

// ---------------- Camera ----------------
async function startCamera() {
  stopCamera();

  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: isBackCamera ? "environment" : "user" },
    audio: false
  });

  video.srcObject = stream;
  await video.play();

  await new Promise(resolve => {
    const check = () =>
      video.videoWidth > 0 ? resolve() : requestAnimationFrame(check);
    check();
  });

  syncCanvasToVideo();
}

function stopCamera() {
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.srcObject = null;
}

// ---------------- Silhouette ----------------
function drawSilhouette(mask) {
  if (!chkMask.checked || !mask) return;

  const mCanvas = mask.getAsCanvas();

  ctx.drawImage(
    mCanvas,
    0, 0,
    canvas.width,
    canvas.height
  );

  const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const d = img.data;

  for (let i = 0; i < d.length; i += 4) {
    const v = d[i]; // mask intensity
    if (v > 15) {
      d[i]   = 30;
      d[i+1] = 90;
      d[i+2] = 160;
      d[i+3] = 180;
    } else {
      d[i+3] = 0;
    }
  }
  ctx.putImageData(img, 0, 0);
}

// ---------------- Loop ----------------
function loop() {
  if (!running || !landmarker) return;

  if (!video.videoWidth) {
    rafId = requestAnimationFrame(loop);
    return;
  }

  ctx.fillStyle = "#bfe7ff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const res = landmarker.detectForVideo(video, performance.now());

  if (res.segmentationMasks?.length) {
    drawSilhouette(res.segmentationMasks[0]);
  }

  if (res.landmarks?.length && chkSkeleton.checked) {
    drawingUtils.drawConnectors(
      res.landmarks[0],
      PoseLandmarker.POSE_CONNECTIONS,
      { color: "#000", lineWidth: 4 }
    );
    drawingUtils.drawLandmarks(
      res.landmarks[0],
      { color: "#000", radius: 3 }
    );
  }

  rafId = requestAnimationFrame(loop);
}

// ---------------- UI ----------------
btnInit.onclick = async () => {
  btnInit.disabled = true;
  setStatus("Initialisiere…");

  await createLandmarker();
  await startCamera();

  running = true;
  btnSwitch.disabled = false;
  loop();

  setStatus("läuft");
};

btnSwitch.onclick = async () => {
  btnSwitch.disabled = true;

  running = false;
  cancelAnimationFrame(rafId);

  isBackCamera = !isBackCamera;

  await startCamera();

  await landmarker.close();
  await createLandmarker();

  running = true;
  loop();

  btnSwitch.disabled = false;
};
</script>
</body>
</html>
